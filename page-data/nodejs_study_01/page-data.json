{"componentChunkName":"component---src-templates-post-jsx","path":"/nodejs_study_01/","result":{"data":{"site":{"siteMetadata":{"title":"Changmin"}},"markdownRemark":{"id":"6db232cd-182b-5ac4-9bae-8158e7ce788f","excerpt":"첫 번째 NodeJS 스터디 주제는 \"싱글 스레드\" 입니다. Javascript를 접하면서 항상 들었던 말은 \"JS는 싱글 스레드 기반의 언어\" 라는 것인데요. 저는, 싱글 스레드 기반이라는 것을 그냥 아 그렇구나 하고 추가적인 학습을 하진 않았어요.  NodeJS가 동작하는 방식을 이해하지 않은 채로 코드를 작성하다보니 왜 콜백 함수를 사용하는지, Pr…","html":"<p>첫 번째 NodeJS 스터디 주제는 \"싱글 스레드\" 입니다. Javascript를 접하면서 항상 들었던 말은 \"JS는 싱글 스레드 기반의 언어\" 라는 것인데요. 저는, 싱글 스레드 기반이라는 것을 그냥 아 그렇구나 하고 추가적인 학습을 하진 않았어요. </p>\n<p>NodeJS가 동작하는 방식을 이해하지 않은 채로 코드를 작성하다보니 왜 콜백 함수를 사용하는지, Promise나 async/await 를 사용하면 어떻게 처리되는지 이해하기가 더 어려워졌습니다. 그래서 이 주제를 선정해 학습을 진행했습니다.</p>\n<h2 id=\"NodeJS-특징\" style=\"position:relative;\"><a href=\"#NodeJS-%ED%8A%B9%EC%A7%95\" aria-label=\"NodeJS 특징 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>NodeJS 특징</h2>\n<p>NodeJS를 접한 사람이라면 특징에 대해서 정말 많이 이야기 들었을거에요.</p>\n<ol>\n<li>Single Thread 기반</li>\n<li>Event Driven 아키텍처</li>\n<li>Non-Blocking I/O 모델</li>\n</ol>\n<p>근데 여기서 한 가지 의문이 생기게 되었어요. 싱글 스레드 기반인데 어떻게 Non-Blocking I/O를 제공한다는 걸까요? 여기서 등장하는 것이 \"이벤트 루프\"입니다. </p>\n<h3 id=\"Event-Loop\" style=\"position:relative;\"><a href=\"#Event-Loop\" aria-label=\"Event Loop permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Event Loop</h3>\n<p>Event Loop 는 NodeJS의 가장 핵심 기능인데요. 일단, 우리가 NodeJS라는 녀석이 싱글 스레드라 불리는 이유는 이 이벤트루프가 메인스레드이면서 싱글스레드로 동작하기 때문입니다. </p>\n<p><img src=\"https://i.imgur.com/OBzGOi7.png\"></p>\n<p><em>[출처]: [빨간색소년: nodejs의 내부 동작 원리](<a href=\"https://sjh836.tistory.com/149?source=post\">https://sjh836.tistory.com/149?source=post</a></em>page-----bb68434027a3--------------------------------)_</p>\n<p>실제로 위의 그림을 보면, libuv 라는 것 안에 이벤트루프가 존재하는 것을 볼 수 있습니다. NodeJS가 싱글 스레드이면서 Non-Blocking I/O를 제공할 수 있는 이유는 libuv 라는 라이브러리 덕분입니다.</p>\n<h3 id=\"libuv\" style=\"position:relative;\"><a href=\"#libuv\" aria-label=\"libuv permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>libuv</h3>\n<p>C언어 기반으로 작성된 라이브러리로, 비동기 I/O를 지원합니다. 커널의 비동기 API로 지원할 수 없는 작업을 비동기 처리할 수 있도록 별도의 Thread Pool을 가지고 있습니다.</p>\n<p>그럼 Thread Pool이 존재하는거니까 싱글 스레드가 아니지 않냐고 이야기할 수도 있지만, 아까 말했듯 NodeJS는 하나의 이벤트루프로만 동작을 합니다. 즉, 싱글 스레드로 이벤트루프가 동작하기 때문에, 싱글 스레드 기반인거죠.</p>\n<h3 id=\"비동기-작업-처리-과정\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%9E%91%EC%97%85-%EC%B2%98%EB%A6%AC-%EA%B3%BC%EC%A0%95\" aria-label=\"비동기 작업 처리 과정 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>비동기 작업 처리 과정</h3>\n<p>그럼 어떻게 비동기 작업들이 처리되는지 순서대로 확인해보겠습니다.</p>\n<ol>\n<li>요청이 들어오면 Event Loop는 해당 요청이 Blocking I/O 작업인지를 판단</li>\n<li>커널의 Non-Blocking I/O 지원을 받을 수 있는 작업이면 커널의 인터페이스로 해당 요청을 처리한 뒤, Event Queue에 해당 작업의 Callback을 등록</li>\n<li>커널의 Non-Blocking I/O 지원을 받을 수 없는 작업이라면 libuv 내 존재하는 Thread Pool에서 Worker Thread를 선택해 해당 작업을 넘김. 이후, 작업이 완료되면 Event Queue로 해당 작업의 Callback을 등록</li>\n<li>Event Loop는 주기적으로 call stack이 비어있는지 확인 후 Event Queue에 실행 대기중인 Callback이 존재한다면 call stack으로 이동시켜 Main Thread에 의해 실행될 수 있게 함</li>\n</ol>\n<h3 id=\"구체적인-예시\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%EC%98%88%EC%8B%9C\" aria-label=\"구체적인 예시 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>구체적인 예시</h3>\n<p>libuv의 역할을 이해하기 위해, 두 가지 예시로 살펴보겠습니다.</p>\n<ol>\n<li>파일 시스템 예시</li>\n</ol>\n<p>예를 들어, 파일을 읽어오는 작업을 수행한다고 가정해보겠습니다. 파일 시스템에 접근하여 데이터를 가져오는 작업은 시간이 걸릴 수 있으며, JavaScript 코드가 이 작업이 완료될 때까지 기다려야 한다면 비효율적입니다. 여기서 libuv가 개입하여, 메인 스레드가 기다리지 않고 다른 작업을 수행할 수 있도록 도와줍니다.</p>\n<blockquote>\n<p>fs.readFile()을 호출하면, Node.js는 이 작업을 libuv로 전달합니다. libuv는 이 작업을 Thread Pool로 넘겨 처리하며, 이때 메인 스레드는 다른 작업을 계속 수행할 수 있습니다. 작업이 완료되면, libuv는 Event Queue에 콜백을 등록해, Event Loop가 그 콜백을 실행하도록 합니다.</p>\n</blockquote>\n<ol start=\"2\">\n<li>네트워크 요청 예시</li>\n</ol>\n<blockquote>\n<p>HTTP 요청도 비슷하게 처리됩니다. 예를 들어, 외부 API 서버에 데이터를 요청하는 경우를 생각해보겠습니다. 일반적으로 네트워크 요청은 상대적으로 시간이 많이 걸리기 때문에, 요청을 보낸 후 그 응답을 기다리는 동안 메인 스레드가 중단된다면 다른 작업을 수행할 수 없습니다.</p>\n<p>네트워크 요청이 발생하면, libuv는 해당 요청을 비동기로 처리하여 응답을 기다리는 동안 메인 스레드가 다른 코드나 이벤트를 처리할 수 있게 합니다. 요청이 완료되면 마찬가지로 Event Queue에 콜백이 등록되어, Event Loop가 그 콜백을 실행합니다.</p>\n</blockquote>\n<p>이와 같은 방식으로, libuv는 파일 읽기, 네트워크 요청, 타이머 설정 등 다양한 비동기 작업을 Thread Pool 또는 OS의 비동기 API를 통해 처리합니다. 덕분에 Node.js는 싱글 스레드 기반임에도 효율적으로 비동기 작업을 수행할 수 있습니다.</p>\n<h2 id=\"마무리하며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0\" aria-label=\"마무리하며 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>마무리하며</h2>\n<p>Node.js의 비동기 처리 방식은 처음에는 복잡하게 느껴질 수 있지만, 핵심은 이벤트 루프와 libuv의 역할을 이해하는 것입니다. 이 두 가지 요소 덕분에 Node.js는 싱글 스레드의 한계를 극복하고, 높은 성능과 효율성을 제공하는 서버 환경을 구축할 수 있게 된거죠.</p>\n<p>우리는 왜 NodeJS가 싱글 스레드 기반이라고 불리는지 확실하게 이해했습니다. 더 나아가, 이를 활용해 적절한 비동기 처리를 통한 성능 향상이나 개선을 하며 코드를 작성할 수 있기를 바랍니다.\n</p>","frontmatter":{"title":"왜 NodeJS는 싱글 스레드인거지?","date":"November 12, 2024","update":"November 12, 2024","tags":["NodeJS"],"series":"NodeJS Study"},"fields":{"slug":"/nodejs_study_01/","readingTime":{"minutes":7.715}}},"seriesList":{"edges":[{"node":{"id":"6db232cd-182b-5ac4-9bae-8158e7ce788f","fields":{"slug":"/nodejs_study_01/"},"frontmatter":{"title":"왜 NodeJS는 싱글 스레드인거지?"}}}]},"previous":{"fields":{"slug":"/do_you_know_singleton/"},"frontmatter":{"title":"싱글톤에 대한 오해"}},"next":null},"pageContext":{"id":"6db232cd-182b-5ac4-9bae-8158e7ce788f","series":"NodeJS Study","previousPostId":"6f049ca8-35b0-532e-8bdf-f12b2c06c72a","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}