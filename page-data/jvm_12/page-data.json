{"componentChunkName":"component---src-templates-post-jsx","path":"/jvm_12/","result":{"data":{"site":{"siteMetadata":{"title":"Changmin"}},"markdownRemark":{"id":"eb82b812-1e72-5dc6-8e49-336d7ccce2a9","excerpt":"5부: 효율적인 동시성 동시성은 현대 컴퓨터의 계산 능력을 최대한 활용하기 위한 강력한 도구입니다. 여러 작업을 동시에 수행함으로써 응답 시간을 줄이고, 시스템의 효율성과 성능을 향상시킬 수 있습니다. 12장: 자바 메모리 모델과 스레드 12.1 들어가며 오늘날의 컴퓨팅 환경에서는 여러 작업을 동시에 처리해야 하는 요구가 증가하고 있습니다. 특히 서버나 …","html":"<h1 id=\"5부-효율적인-동시성\" style=\"position:relative;\"><a href=\"#5%EB%B6%80-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EB%8F%99%EC%8B%9C%EC%84%B1\" aria-label=\"5부 효율적인 동시성 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>5부: 효율적인 동시성</h1>\n<p>동시성은 현대 컴퓨터의 계산 능력을 최대한 활용하기 위한 강력한 도구입니다. 여러 작업을 동시에 수행함으로써 응답 시간을 줄이고, 시스템의 효율성과 성능을 향상시킬 수 있습니다.</p>\n<h2 id=\"12장-자바-메모리-모델과-스레드\" style=\"position:relative;\"><a href=\"#12%EC%9E%A5-%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"12장 자바 메모리 모델과 스레드 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>12장: 자바 메모리 모델과 스레드</h2>\n<h3 id=\"121-들어가며\" style=\"position:relative;\"><a href=\"#121-%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"121 들어가며 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>12.1 들어가며</h3>\n<p>오늘날의 컴퓨팅 환경에서는 여러 작업을 동시에 처리해야 하는 요구가 증가하고 있습니다. 특히 서버나 대규모 애플리케이션에서는 동시에 많은 요청을 처리해야 하며, 이는 효율적인 동시성 프로그래밍을 필요로 합니다.</p>\n<br>\n<p>하지만 동시성 프로그래밍은 여러 스레드 간의 데이터 공유와 동기화 문제로 인해 복잡하고 어려운 기술입니다. 자바는 이러한 복잡성을 완화하기 위해 자바 메모리 모델(JMM)과 스레드 관련 기능을 제공합니다.</p>\n<h3 id=\"122-하드웨어에서의-효율과-일관성\" style=\"position:relative;\"><a href=\"#122-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%97%90%EC%84%9C%EC%9D%98-%ED%9A%A8%EC%9C%A8%EA%B3%BC-%EC%9D%BC%EA%B4%80%EC%84%B1\" aria-label=\"122 하드웨어에서의 효율과 일관성 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>12.2 하드웨어에서의 효율과 일관성</h3>\n<h4 id=\"프로세서와-메모리의-속도-차이\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%99%80-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%86%8D%EB%8F%84-%EC%B0%A8%EC%9D%B4\" aria-label=\"프로세서와 메모리의 속도 차이 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>프로세서와 메모리의 속도 차이</h4>\n<p>프로세서는 매우 빠른 속도로 연산을 수행하지만, 메인 메모리의 접근 속도는 상대적으로 느립니다. 이로 인해 프로세서의 연산 능력을 충분히 활용하지 못하는 병목 현상이 발생합니다.</p>\n<h4 id=\"캐시의-등장과-캐시-일관성-문제\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C%EC%9D%98-%EB%93%B1%EC%9E%A5%EA%B3%BC-%EC%BA%90%EC%8B%9C-%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AC%B8%EC%A0%9C\" aria-label=\"캐시의 등장과 캐시 일관성 문제 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>캐시의 등장과 캐시 일관성 문제</h4>\n<p>이러한 속도 차이를 해소하기 위해 <strong>캐시(Cache)</strong>가 도입되었습니다. 캐시는 프로세서와 메인 메모리 사이에 위치하여 자주 사용하는 데이터를 빠르게 접근할 수 있도록 합니다.</p>\n<br>\n<p>그러나 멀티프로세서 시스템에서는 각 프로세서가 자체 캐시를 가지고 있어 캐시 일관성(Cache Coherence) 문제가 발생합니다. 한 프로세서가 메모리를 변경해도 다른 프로세서의 캐시에 그 변경 사항이 즉시 반영되지 않을 수 있습니다.</p>\n<h4 id=\"메모리-모델과-명령어-재정렬\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%9E%AC%EC%A0%95%EB%A0%AC\" aria-label=\"메모리 모델과 명령어 재정렬 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>메모리 모델과 명령어 재정렬</h4>\n<p>캐시 일관성 문제를 해결하기 위해 하드웨어 수준에서 메모리 모델과 캐시 일관성 프로토콜이 사용됩니다. 또한 프로세서의 성능 향상을 위해 <strong>명령어 재정렬(Instruction Reordering)</strong>과 <strong>비순차 실행(Out-of-Order Execution)</strong>이 활용되는데, 이는 프로그램의 실행 순서가 코드 작성 순서와 다를 수 있음을 의미합니다.</p>\n<br>\n<p>이러한 최적화는 성능 면에서 이점이 있지만, 동시성 프로그래밍에서는 예상치 못한 결과를 초래할 수 있습니다.</p>\n<h3 id=\"123-자바-메모리-모델\" style=\"position:relative;\"><a href=\"#123-%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%A8%EB%8D%B8\" aria-label=\"123 자바 메모리 모델 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>12.3 자바 메모리 모델</h3>\n<h4 id=\"자바-메모리-모델의-필요성\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%A8%EB%8D%B8%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"자바 메모리 모델의 필요성 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>자바 메모리 모델의 필요성</h4>\n<p>자바는 다양한 플랫폼에서 동일한 동작을 보장하기 위해 <strong>자바 메모리 모델(JMM)</strong>을 정의합니다. JMM은 스레드가 메모리에 접근하고 상호 작용하는 방식을 규정하여 일관된 프로그램 동작을 보장합니다.</p>\n<h4 id=\"메인-메모리와-작업-메모리\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%9D%B8-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EC%9E%91%EC%97%85-%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"메인 메모리와 작업 메모리 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>메인 메모리와 작업 메모리</h4>\n<p>JMM에서는 모든 변수가 메인 메모리에 저장되며, 각 스레드는 자신의 <strong>작업 메모리(Working Memory)</strong>를 가지고 있습니다. 스레드는 변수를 사용할 때 메인 메모리에서 작업 메모리로 변수를 가져와 사용하고, 변경된 값은 다시 메인 메모리에 저장합니다.</p>\n<br>\n<p>이러한 구조로 인해 스레드 간에 변수의 변경 사항이 즉시 반영되지 않을 수 있으며, 이를 메모리 가시성(Memory Visibility) 문제라고 합니다.</p>\n<h4 id=\"volatile-키워드\" style=\"position:relative;\"><a href=\"#volatile-%ED%82%A4%EC%9B%8C%EB%93%9C\" aria-label=\"volatile 키워드 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>volatile 키워드</h4>\n<p>변수의 변경 사항이 즉시 다른 스레드에 반영되도록 하기 위해 volatile 키워드를 사용할 수 있습니다. volatile로 선언된 변수는 다음과 같은 특징을 가집니다.</p>\n<ul>\n<li>가시성 보장: 한 스레드가 변수의 값을 변경하면 즉시 메인 메모리에 저장되며, 다른 스레드는 메인 메모리에서 그 값을 읽어옵니다.</li>\n<li>명령어 재정렬 방지: 컴파일러와 프로세서의 최적화에 의해 명령어 순서가 변경되는 것을 방지합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">VolatileExample</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">boolean</span> flag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">updateFlag</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">checkFlag</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// flag가 변경되었음을 감지</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>하지만 volatile은 복합 연산의 원자성을 보장하지 않으므로 주의가 필요합니다.</p>\n<h4 id=\"원자성Atomicity과-동기화\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EC%9E%90%EC%84%B1Atomicity%EA%B3%BC-%EB%8F%99%EA%B8%B0%ED%99%94\" aria-label=\"원자성Atomicity과 동기화 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>원자성(Atomicity)과 동기화</h4>\n<p>복합 연산(예: i++)은 읽기와 쓰기가 결합된 연산으로, 여러 스레드가 동시에 접근하면 예상치 못한 결과를 가져올 수 있습니다. 이를 해결하기 위해 synchronized 키워드를 사용하여 원자성을 보장할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Counter</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>synchronized를 사용하면 한 번에 하나의 스레드만 해당 메서드나 블록을 실행할 수 있어 데이터의 일관성을 유지할 수 있습니다.</p>\n<h3 id=\"124-자바와-스레드\" style=\"position:relative;\"><a href=\"#124-%EC%9E%90%EB%B0%94%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"124 자바와 스레드 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>12.4 자바와 스레드</h3>\n<h4 id=\"스레드의-개념과-운영체제의-스레드-모델\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%AA%A8%EB%8D%B8\" aria-label=\"스레드의 개념과 운영체제의 스레드 모델 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>스레드의 개념과 운영체제의 스레드 모델</h4>\n<p>스레드는 프로세스 내에서 실행 흐름을 분리하여 동시에 여러 작업을 수행할 수 있게 합니다. 운영체제는 스레드를 관리하는 방식에 따라 커널 스레드, 사용자 스레드, 하이브리드 스레드 모델을 제공합니다.</p>\n<ul>\n<li>커널 스레드: 운영체제가 관리하며, 각 스레드는 운영체제의 스케줄러에 의해 관리됩니다.</li>\n<li>사용자 스레드: 애플리케이션 레벨에서 관리되며, 운영체제는 단일 스레드로 인식합니다.</li>\n<li>하이브리드 스레드: 사용자 스레드와 커널 스레드가 매핑되어 운영됩니다.</li>\n</ul>\n<h4 id=\"자바-스레드와-JNI\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80-JNI\" aria-label=\"자바 스레드와 JNI permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>자바 스레드와 JNI</h4>\n<p>자바에서 스레드를 생성하면 실제로는 운영체제의 커널 스레드가 생성됩니다. 이는 <strong>JNI(Java Native Interface)</strong>를 통해 자바가 운영체제의 기능을 활용하기 때문입니다.</p>\n<br>\n<p>Thread 클래스의 start() 메서드를 보면 내부적으로 네이티브 메서드 start0()를 호출하여 스레드를 시작합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ...</span>\n        <span class=\"token function\">start0</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">native</span> <span class=\"token keyword\">void</span> <span class=\"token function\">start0</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4 id=\"기존-스레드-모델의-한계\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%A1%B4-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%AA%A8%EB%8D%B8%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"기존 스레드 모델의 한계 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>기존 스레드 모델의 한계</h4>\n<p>기존의 자바 스레드는 운영체제의 스레드와 1:1 매핑되므로 많은 수의 스레드를 생성하면 메모리 소비와 스케줄링 오버헤드가 증가합니다.</p>\n<ul>\n<li>메모리 소비: 각 스레드는 독립적인 스택 메모리를 가지며, 많은 스레드를 생성하면 메모리 사용량이 크게 증가합니다.</li>\n<li>스케줄링 오버헤드: 운영체제의 스케줄러가 많은 스레드를 관리해야 하므로 컨텍스트 스위칭 비용이 증가합니다.</li>\n</ul>\n<h4 id=\"가상-스레드Virtual-Threads의-도입\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9CVirtual-Threads%EC%9D%98-%EB%8F%84%EC%9E%85\" aria-label=\"가상 스레드Virtual Threads의 도입 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>가상 스레드(Virtual Threads)의 도입</h4>\n<p>이러한 문제를 해결하기 위해 JDK 21에서는 <strong>가상 스레드(Virtual Threads)</strong>가 도입되었습니다. 가상 스레드는 경량화된 스레드로, 운영체제의 스레드와 1:1 매핑되지 않고 자바 레벨에서 관리됩니다.</p>\n<ul>\n<li>경량성: 스레드 생성 비용이 낮으며, 수많은 스레드를 생성할 수 있습니다.</li>\n<li>높은 동시성: 블로킹 I/O 작업에서도 스레드가 블로킹되지 않고 효율적으로 처리됩니다.</li>\n<li>코드의 간결성: 비동기 프로그래밍의 복잡성을 줄이고, 동기식 코드 스타일을 유지하면서도 높은 성능을 제공합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">VirtualThreadExample</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">startVirtualThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 가상 스레드에서 실행할 코드</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"가상 스레드 실행 중\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"125-자바와-가상-스레드\" style=\"position:relative;\"><a href=\"#125-%EC%9E%90%EB%B0%94%EC%99%80-%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"125 자바와 가상 스레드 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>12.5 자바와 가상 스레드</h3>\n<p>가상 스레드가 왜 필요하고, 왜 사용해야할까요?</p>\n<h4 id=\"기존-자바-스레드-모델\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%A1%B4-%EC%9E%90%EB%B0%94-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%AA%A8%EB%8D%B8\" aria-label=\"기존 자바 스레드 모델 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>기존 자바 스레드 모델</h4>\n<p>자바에서는 멀티 스레드를 지원하는 언어라는 것은 다들 알고 계실거에요. 우리가 사용 중인 스프링 프레임워크에서도 멀티 스레드 모델을 사용하고 있죠. 1개의 요청을 1개의 스레드가 처리하는 thread-per-request 방식으로 동작하고 있는데, 동시 요청이 많아진다면 스레드의 수가 증가해야 이를 대응할 수 있습니다.</p>\n<p>기존 자바 스레드 모델은 Native Thread 인데요. Java의 유저 스레드를 생성하면 JNI를 통해서 커널 영역을 호출하고 OS가 커널 스레드를 생성해 매핑한 뒤 작업을 수행하는 형태입니다. 또한, 이렇게 생성된 Thread는 1:1로 구현됩니다. 이는 각 Java의 유저 스레드가 OS의 커널 스레드에 1:1로 대응된다는 것을 의미합니다. 이는 아래와 같은 문제점을 가지고 있는데요.</p>\n<ul>\n<li><strong>컨텍스트 스위칭 비용:</strong> 커널 스레드 간 전환에는 높은 비용이 발생합니다.</li>\n<li><strong>메모리 소모:</strong> 각 스레드마다 큰 스택 공간(보통 1MB)이 필요합니다.</li>\n<li><strong>리소스 제한:</strong> OS 커널 스레드의 수 제한으로 인해 많은 동시 작업 처리에 부적합합니다.</li>\n</ul>\n<p>Java 유저 스레드가 늘어나면 OS의 커널 스레드도 똑같이 증가해야겠죠? 그럼 당연하게도 컨텍스트 스위칭에 대한 오버헤드가 증가하고, 리소스에 대해서도 문제가 계속 생겨나게 됩니다.</p>\n<h4 id=\"가상-스레드-등장\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%93%B1%EC%9E%A5\" aria-label=\"가상 스레드 등장 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>가상 스레드 등장</h4>\n<p>기존의 자바 스레드 모델 문제점을 해결하기 위해 가상 스레드가 등장하게 되었습니다.</p>\n<h4 id=\"가상-스레드란\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%9E%80\" aria-label=\"가상 스레드란 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>가상 스레드란?</h4>\n<p>가상 스레드는 경량 스레드로, 하나의 커널 스레드 위에서 여러 개의 가상 스레드가 실행될 수 있습니다. 가상 스레드는 JVM 내에서 유저 스레드로 구현되고, 커널 스레드와 독립적으로 스케줄링될 수 있기 때문이죠. 그래서 이를 \"플랫폼 스레드\"와 \"가상 스레드\" 구분할 수 있는데, 플랫폼 스레드 위에서 가상 스레드가 번갈아 가며 실행되는 형태로 동작합니다.</p>\n<p>더 많은 요청을 처리하고, 스레드 간 컨텍스트 스위칭 비용을 줄이기 위해 가상 스레드는 어떤 방식으로 동작을 할까요?</p>\n<h4 id=\"가상-스레드의-특징\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"가상 스레드의 특징 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>가상 스레드의 특징</h4>\n<p>가장 큰 특징은 기존 스레드와는 달리 가볍기 때문에, 컨텍스트 스위칭 비용이 상당히 낮아진다는 것입니다. 또한, JVM에 의해 관리되기 때문에 실제 커널 영역의 호출이 적어지는 특징도 존재하죠.</p>\n<ul>\n<li><strong>저비용 생성:</strong> 가상 스레드는 1~2KB의 메모리만 필요로 합니다.</li>\n<li><strong>블로킹 작업 처리:</strong> I/O 블로킹 시, 작업을 중단(yield)하고 캐리어 스레드를 반환하여 리소스 낭비를 줄입니다.</li>\n<li><strong>JVM 기반 스케줄링:</strong> 운영체제 대신 JVM이 가상 스레드의 스케줄링을 담당합니다.</li>\n</ul>\n<h4 id=\"가상-스레드와-플랫폼-스레드-비교\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%B9%84%EA%B5%90\" aria-label=\"가상 스레드와 플랫폼 스레드 비교 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>가상 스레드와 플랫폼 스레드 비교</h4>\n<table>\n<thead>\n<tr>\n<th>특징</th>\n<th>기존 스레드</th>\n<th>가상 스레드</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>스레드 관리</strong></td>\n<td>OS 스케줄러</td>\n<td>JVM 내부 스케줄링</td>\n</tr>\n<tr>\n<td><strong>메모리 사용량</strong></td>\n<td>최대 2MB</td>\n<td>최대 10KB</td>\n</tr>\n<tr>\n<td><strong>컨텍스트 스위칭 비용</strong></td>\n<td>높음</td>\n<td>낮음</td>\n</tr>\n<tr>\n<td><strong>스레드 생성 비용</strong></td>\n<td>상대적으로 높음</td>\n<td>매우 낮음</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>마무리</h2>\n<p>자바는 초기부터 멀티스레드 지원을 통해 동시성 프로그래밍을 가능하게 했지만, 기존의 플랫폼 스레드 기반 모델은 메모리 소모와 컨텍스트 스위칭 비용 등 여러 한계가 존재했습니다. 이러한 문제를 해결하기 위해 JDK 21에서 가상 스레드가 도입되었으며, 이는 자바에서의 동시성 프로그래밍 패러다임에 중요한 변화를 가져왔습니다.</p>\n<p>가상 스레드는 더 많은 동시 요청을 효율적으로 처리할 수 있도록 설계되어 I/O 중심의 애플리케이션에서 특히 강력한 이점을 제공합니다. 또한, 동기식 코드 스타일을 유지하면서도 비동기 프로그래밍의 성능과 확장성을 누릴 수 있게 해주죠.</p>\n<p>또한 가상 스레드는 컨텍스트 스위칭 비용이 낮기 때문에, I/O 작업 시 Blocking이 잦아 System Call 이 자주 발생하는 서비스라면 가상 스레드를 사용하는 것이 효율적이지만, 그렇지 않은 경우에는 굳이 도입할 이유도 없어보입니다.</p>","frontmatter":{"title":"12장 : 자바 메모리 모델과 스레드","date":"November 27, 2024","update":"December 04, 2024","tags":["JVM","JAVA","동시성"],"series":"JVM 밑바닥까지 파헤치기"},"fields":{"slug":"/jvm_12/","readingTime":{"minutes":16.745}}},"seriesList":{"edges":[{"node":{"id":"eb82b812-1e72-5dc6-8e49-336d7ccce2a9","fields":{"slug":"/jvm_12/"},"frontmatter":{"title":"12장 : 자바 메모리 모델과 스레드"}}}]},"previous":{"fields":{"slug":"/TIL_02/"},"frontmatter":{"title":"추상과 구체"}},"next":{"fields":{"slug":"/TIL_03/"},"frontmatter":{"title":"글로벌 물류 네트워크 백엔드 서비스 설계"}}},"pageContext":{"id":"eb82b812-1e72-5dc6-8e49-336d7ccce2a9","series":"JVM 밑바닥까지 파헤치기","previousPostId":"fdfb781b-76ef-5a0d-bc37-cb3adda3a06c","nextPostId":"4ff09561-63c2-5b6f-9d4c-efa7bdc13b5c"}},"staticQueryHashes":[],"slicesMap":{}}