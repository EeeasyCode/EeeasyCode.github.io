{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"3. 애그리거트 3.1 애그리거트 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려움. '나무를 보지 말고 숲을 보라'는 말처럼 전체적인 흐름을 이해하기 위해서는 큰 덩어리로 먼저 볼 필요가 있음. 애그리거트 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들기 위해 상…","fields":{"slug":"/ddd-start-ch03/"},"frontmatter":{"date":"June 23, 2024","title":"도메인 주도 개발 시작하기 - 3장","tags":["DDD","study"]},"rawMarkdownBody":"\n# 3. 애그리거트\n\n## 3.1 애그리거트\n\n도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려움.\n\n> '나무를 보지 말고 숲을 보라'는 말처럼 전체적인 흐름을 이해하기 위해서는 큰 덩어리로 먼저 볼 필요가 있음.\n\n### 애그리거트\n\n복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들기 위해 상위 수준에서 모델을 조망할 수 있는 방법임. 도메인에 관련된 객체를 하나의 군으로 묶어 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있음.\n\n애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 됨. 모델을 보다 잘 이해할 수 있고 애그리거트 단위로 일관성을 관리하기 때문에, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어줌. 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력도 줄어듦.\n\n애그리거트는 관련 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 가짐. 애그리거트는 경계를 가지며, 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않음. 애그리거트는 독립된 객체 군이며 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않음.\n\n예를 들어, 주문 애그리거트는 배송지를 변경하거나 주문 상품 개수를 변경하는 등의 기능을 관리하지만, 주문 애그리거트에서 회원의 비밀번호를 변경하거나 상품의 가격을 변경하지 않음.\n\n경계를 설정할 때는 도메인 규칙과 요구사항을 따름. 도메인 규칙에 따라 함께 생성된 구성요소는 한 애그리거트에 속할 가능성이 높고, 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높음.\n\n'A가 B를 갖는다'로 설계할 수 있는 요구사항이 있더라도 반드시 A와 B가 한 애그리거트에 속하는 것을 의미하지는 않음. 예를 들어, 상품과 리뷰는 함께 생성되지 않고, 함께 변경되지도 않기 때문에 서로 다른 애그리거트에 속함.\n\n## 3.2 애그리거트 루트\n\n### 애그리거트 루트 엔티티\n\n애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요함. 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속함.\n\n예를 들어, 주문 애그리거트의 루트 역할을 하는 엔티티는 `Order`이며, `OrderLine`, `ShippingInfo`, `Orderer` 등은 `Order`에 속함.\n\n### 도메인 규칙과 일관성\n\n애그리거트 루트는 애그리거트의 일관성이 깨지지 않도록 하는 핵심 역할을 함. 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현함.\n\n예를 들어, 주문 애그리거트는 배송지 변경, 상품 변경과 같은 기능을 제공하고, 애그리거트 루트인 `Order`가 이 기능을 구현한 메서드를 제공해야 함. 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 함.\n\n애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안 됨. 이는 애그리거트 루트가 강제하는 규칙 적용이 불가하여 모델의 일관성을 깨는 원인이 됨.\n\n```java\nShippingInfo si = order.getShippingInfo();\nsi.setAddress(newAddress);\n```\n\n이 코드는 애그리거트 루트인 Order에서 ShippingInfo를 가져와 직접 정보를 변경하고 있음.\n주문 상태와 관계없이 배송지 주소를 변경하는 행위는 규칙을 무시하고 직접 DB 테이블의 데이터를 수정하는 것과 동일한 결과를 초래함.\n즉, 논리적인 데이터 일관성이 깨지게 됨.\n일관성을 유지하기 위해 상태 확인 로직을 서비스에 구현할 수 있으나, 이는 중복 구현될 가능성이 있어 유지 보수가 어려워질 수 있음.\n\n```java\nShippingInfo si = order.getShippingInfo();\n// 상태 확인 로직 -> 중복 구현 가능성 존재\nif (state != OrderState.PAYMENT_WAITING || state != OrderState.PREPARING) {\n    throw new IllegalArgumentException();\n}\nsi.setAddress(newAddress);\n```\n\n애그리거트 루트를 통해 도메인 로직을 구현하려면 도메인 모델에 두 가지 습관을 적용해야 함.\n\n첫째, 필드를 변경하는 set 메서드는 공개(public) 범위로 만들지 않음.\n둘째, 밸류 타입은 불변으로 구현함.\n특히 public set 메서드 작성은 지양해야 함.\n\n```java\npublic void setName(String name) {\n    this.name = name;\n}\n```\n\npublic set 메서드는 도메인의 의미나 의도를 제대로 표현 못 하고, 도메인 로직을 도메인 객체가 아닌 응용 영역이나 표현 영역으로 흩어지게 만듦. 이렇게 도메인 로직이 한 곳에 모이지 않으면 유지 보수할 때 분석하거나 수정하는 데 시간 많이 듦.\n\n도메인 모델의 엔티티나 밸류에서 public set 메서드를 안 쓰면 일관성 깨질 가능성 줄어듦. 의미가 드러나는 메서드를 쓰게 되는 경우가 많아짐. 예를 들어, cancel이나 changePassword 같은 메서드 말이야.\n\npublic set 메서드를 안 만드는 걸로 끝나지 않고, 밸류를 불변 타입으로 구현함. 밸류 객체의 값을 변경 못 하게 되면, 애그리거트 루트에서 밸류 객체를 구해도 애그리거트 외부에서 밸류 객체 상태를 변경 못 함.\n\n```java\nShippingInfo si = order.getShippingInfo();\n// ShippingInfo가 불변이면, 이 코드는 컴파일 에러가 발생함\nsi.setAddress(newAddress);\n```\n\n애그리거트 외부에서 내부 상태를 함부로 변경 못 하게 되어 애그리거트의 일관성이 깨질 가능성이 줄어듦. 밸류 객체가 불변이라면 밸류 객체의 값을 변경할 방법은 새로운 밸류 객체를 할당하는 것뿐. 즉, 애그리거트 루트가 제공하는 메서드에 새로운 밸류 객체를 전달해서 값을 변경하는 방법 밖에 없음.\n\n```java\npublic class Order {\n    private ShippingInfo shippingInfo;\n\n    public void changeShippingInfo(ShippingInfo shippingInfo) {\n        verifyNotYetShipped();\n        setShippingInfo(newShippingInfo);\n\n        // set 메서드의 접근 허용 범위는 private임\n        private void setShippingInfo(ShippingInfo newShippingInfo) {\n            // 밸류가 불변이면 새로운 객체를 할당해서 값을 변경해야 함\n            // 불변이므로 this.shippingInfo.setAddress(newShippingInfo.getAddress()) 와 같은 코드 사용 X\n\n            this.shippingInfo = newShippingInfo;\n        }\n    }\n}\n```\n\n밸류 타입의 내부 상태 변경은 애그리거트 루트를 통해서만 가능. 애그리거트 루트가 도메인 규칙을 제대로 구현하면 애그리거트 전체 일관성 유지 가능.\n\n### 애그리거트 루트 기능 구현\n\n애그리거트 루트는 애그리거트 내부의 다른 객체들을 조합해 기능 완성. 예를 들어, Order는 OrderLine 목록을 활용해 총 주문 금액 계산.\n\n애그리거트 루트는 구성요소의 상태 참조뿐만 아니라 기능 실행도 위임. 예를 들어, OrderLines 클래스로 분리된 후 Order의 changeOrderLines() 메서드는 내부 orderLines 필드에 상태 변경을 위임해 기능 구현 가능.\n\n```java\npublic class Order {\n    private OrderLines orderLines;\n\n    public void changeOrderLines(List<OrderLine> newLines) {\n        orderLines.changeOrderLines(newLines);\n        this.totalAmounts = orderLines.getTotalAmounts();\n    }\n}\n```\n\nOrderLines는 changeOrderLines(), getTotalAmounts() 등의 기능 제공. Order에서 getOrderLines() 메서드로 OrderLines 접근 가능하면, 애그리거트 외부에서도 OrderLines 기능 실행 가능.\n\n```java\nOrderLines lines = order.getOrderLines();\nlines.changeOrderLines(newOrderLines);\n```\n\n주문의 OrderLine 목록 변경 시 총합 계산 안 함. 버그 발생. OrderLines를 불변으로 만들거나 패키지나 protected 범위로 외부 변경 방지 필요.\n\n### 트랜잭션 범위\n\n트랜잭션 범위는 작을수록 좋음. 한 트랜잭션은 하나의 애그리거트만 수정해야 함. 두 개 이상의 애그리거트 수정 시 충돌 가능성 높아져 처리량 저하 발생 가능.\n\n한 트랜잭션에서 한 애그리거트만 수정하는 건 애그리거트가 다른 애그리거트 변경 안 한다는 의미.\n\n예로, 배송지 정보 변경하면서 회원의 주소로 설정하는 기능은 애그리거트가 책임 범위 넘어 다른 애그리거트 상태까지 관리하는 꼴. 애그리거트는 독립적이어야 하며, 의존 시작하면 결합도 높아짐.\n\n```java\npublic class Order {\n    private Orderer orderer;\n\n    public void shipTo(ShippingInfo newShippingInfo, boolean useNewShippingAddrAsMemberAddr) {\n        verifyNotYetShipped();\n        setShippingInfo(newShippingInfo);\n        if (useNewShippingAddrAsMemberAddr) {\n            orderer.getMember().changeAddress(newShippingInfo.getAddress());\n        }\n    }\n}\n```\n\n애그리거트 간 상태 변경은 허용되지 않음. 한 트랜잭션에서 여러 애그리거트 수정 필요 시, 서비스 레벨에서 처리 구현 필요.\n\n```java\npublic class ChangeOrderService {\n    @Transactional\n    public void changeShippingInfo(OrderId id, ShippingInfo shippingInfo, boolean useNewShippingAddrAsMemberAddr) {\n        Order order = orderRepository.findById(id);\n        if (order == null) throw new OrderNotFoundException();\n        order.shipTo(newShippingInfo);\n        if (useNewShippingAddrAsMemberAddr) {\n            Member member = findMember(order.getOrderer());\n            member.changeAddress(newShippingInfo.getAddress());\n        }\n    }\n}\n```\n\n한 트랜잭션에서 한 개의 애그리거트 변경을 권장하지만, 때로는 두 개 이상의 애그리거트 변경이 필요한 상황도 발생함.\n\n## 3.3 리포지터리와 애그리거트\n\n애그리거트는 도메인 모델 전체를 표현하는 개념적 단위임. 따라서 객체의 영속성을 관리하는 리포지터리도 애그리거트 단위로 존재함.\n\n새 애그리거트 생성 시 저장소에 영속화하고, 사용 시에는 저장소에서 읽어야 함. 리포지터리는 주로 다음 두 메서드를 제공함:\n\n- save: 애그리거트 저장\n- findById: ID로 애그리거트 찾기\n  필요에 따라 다양한 검색 조건으로 애그리거트를 찾거나 삭제하는 메서드도 추가 가능함.\n\n리포지터리 구현 방식은 사용하는 기술에 따라 달라짐. 예를 들어 JPA 같은 ORM 기술을 사용하면 데이터베이스 모델에 맞춰 객체 모델을 조정해야 할 때도 있음.\n\n애그리거트는 개념적으로 하나이기 때문에 리포지터리는 애그리거트 전체를 저장소에 영속화해야 함.\n\n## 3.4 ID를 이용한 애그리거트 참조\n\n애그리거트는 다른 애그리거트를 참조할 수 있음. 애그리거트의 관리는 애그리거트 루트가 담당하므로, 다른 애그리거트를 참조한다는 것은 그 루트를 참조하는 것과 같음.\n\n애그리거트 간 참조는 필드를 통해 구현 가능함. 하지만 이 방식은 다음과 같은 문제를 일으킬 수 있음:\n\n- 편한 탐색 오용: 다른 애그리거트를 쉽게 수정하려는 유혹에 빠질 수 있음.\n- 성능 고민: JPA를 사용할 경우, 참조한 객체를 지연 로딩이나 즉시 로딩으로 처리해야 함.\n- 확장 어려움: 사용자 증가와 트래픽 증가에 따라 시스템을 분리해야 할 수도 있음.\n  이런 문제를 해결하기 위해 ID를 이용한 참조 방식을 사용함. 이 방법은 애그리거트 간 물리적 연결을 제거하고, 모델의 복잡도를 낮추며, 응집도를 높임.\n\nID 참조를 사용하면서 발생할 수 있는 N+1 조회 문제는 조회 전용 쿼리로 해결 가능함. 데이터 조회를 위해 별도의 DAO를 만들고, 조인을 이용해 한 번의 쿼리로 필요한 데이터를 로딩할 수 있음.\n\n애그리거트마다 다른 저장소를 사용하면 한 번의 쿼리로 관련 애그리거트를 조회할 수 없음. 이 경우 캐시 적용이나 조회 전용 저장소 구성을 통해 조회 성능을 높일 수 있음. 이 방법은 코드 복잡성을 증가시키지만 시스템 처리량을 높일 수 있는 장점이 있음.\n\n## 3.5 애그리거트 간 집합 연관\n\n애그리거트 간 1:1 관계는 Set 같은 컬렉션으로 표현 가능함. 하지만 개념적으로 존재하는 애그리거트 간의 1:1 연관을 실제 구현에 반영하지 않을 때도 있음. 성능 문제 때문에 애그리거트 간의 1:1 연관을 구현에 반영하지 않을 수 있음.\n\n## 3.6 애그리거트를 팩토리로 사용하기\n\n애그리거트를 팩토리로 사용하면 도메인 로직이 응용 서비스에 노출되지 않고, 도메인의 응집도가 높아짐.\n\n예를 들어, 고객이 특정 상점을 여러 번 신고해 해당 상점이 물건을 등록하지 못하도록 차단한 상태라고 가정함.\n\n```java\npublic class RegisterProductService {\n    public ProductId registerNewProduct(NewProductRequest req) {\n        Store account = accountRepository.findStoreById(req.getStoreId());\n        checkNull(account);\n        if (!account.isBlocked()) {\n            throw new StoreBlockedException();\n        }\n        ProductId id = productRepository.nextId();\n        Product product = new Product(id, account.getId(), ...);\n        productRepository.save(product);\n        return id;\n    }\n}\n```\n\n위 코드는 Store가 Product를 생성할 수 있는지를 판단하고 Product를 생성하는 논리적 도메인 기능을 응용 서비스에서 구현하고 있습니다.\n\n이를 개선하기 위해 Store 애그리거트에 Product 애그리거트를 생성하는 팩토리 역할을 추가합니다.\n\n```java\npublic class Store {\n    public Product createProduct(ProductId newProductId, ...) {\n        if (isBlocked()) throw new StoreBlockedException();\n        return new Product(newProductId, getId(), ...);\n    }\n}\n```\n\nStore에서 Product를 생성하도록 변경하면 다음과 같은 차이점이 발생함.\n\n- 응용 서비스에서 Store의 상태를 확인할 필요가 없어짐.\n- Store 관련 로직은 모두 Store 내부에서 구현됨.\n- Product 생성 로직도 Store 내부로 이동함.\n- 도메인의 응집도가 높아짐.\n\n```java\npublic class RegisterProductService {\n    public ProductId registerNewProduct(NewProductRequest req) {\n        Store account = accountRepository.findStoreById(req.getStoreId());\n        checkNull(account);\n        ProductId id = productRepository.nextId();\n        Product product = account.createProduct(id, account.getId(), ...);\n        productRepository.save(product);\n        return id;\n    }\n}\n```\n"},{"excerpt":"Feature 빌드 속도를 개선하기 위해, yarn classic -> yarn berry (zero install) -> pnpm으로 마이그레이션 하는 과정과 docker multi-stage 적용, nestjs에서 swc를 통한 컴파일 속도 최적화를 진행했습니다. Situation 현재 저희는 AWS ECS를 통해 서버를 배포하고 있습니다. githu…","fields":{"slug":"/nestjs-build-time/"},"frontmatter":{"date":"June 18, 2024","title":"nestjs 빌드 속도 개선","tags":["nestjs","package manager","성능 개선"]},"rawMarkdownBody":"\n# Feature\n\n빌드 속도를 개선하기 위해, **yarn classic -> yarn berry (zero install) -> pnpm**으로 마이그레이션 하는 과정과 **docker multi-stage** 적용, nestjs에서 **swc**를 통한 컴파일 속도 최적화를 진행했습니다.\n\n## Situation\n\n현재 저희는 **AWS ECS**를 통해 서버를 배포하고 있습니다. github의 코드가 **docker image**로 빌드되고, **AWS ECR**을 거쳐 **AWS ECS**의 인스턴스로 생성되는 파이프라인이 구성되어 있습니다.\n\n## Task\n\n- package 설치 속도 및 의존성 관리 개선\n- docker 빌드 속도 개선\n- nestjs 빌드 · 컴파일 속도 개선\n\n## Action\n\n### package manager 마이그레이션\n\n기존 yarn classic에서 yarn berry (zero-install)을 업그레이드한 뒤, 다양한 고려사항으로 인해 pnpm으로 최종 마이그레이션을 진행했습니다.\n\n실제 pacakge 설치 속도 및 크기를 크게 개선할 수 있었습니다.\n| yarn classic | pnpm |\n| ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |\n| 153.4s | 49.0s |\n\n> package manager 마이그레이션 과정은 해당 포스팅에서 확인할 수 있습니다.\n\n### docker multi-stage 적용\n\n### nestjs에서 swc 적용\n\n## Result\n\n해당 작업 결과로 docker 이미지 빌드 시간은 301.6s -> 112.6s 로 개선했고,\n이미지 용량도 1GB -> 830MB로 감소시킬 수 있었다.\n| yarn classic | pnpm |\n| ------------------------------------ | ------------------------------------ |\n| [+] Building 301.6s (12/12) FINISHED | [+] Building 112.6s (17/17) FINISHED |\n\n<img width=\"1157\" alt=\"upload_test\" src=\"https://imgur.com/zJUQ9n9.png\">\n"},{"excerpt":"최범균 저자님의 '도메인 주도 개발 시작하기' 라는 책을 스터디하기로 했다. 스터디는 이번에 활동하고 있는 YAPP 24기 스터디에서 진행한다.","fields":{"slug":"/ddd-start-intro/"},"frontmatter":{"date":"June 16, 2024","title":"도메인 주도 개발 시작하기 - YAPP 24기 스터디","tags":["DDD","study"]},"rawMarkdownBody":"\n최범균 저자님의 '도메인 주도 개발 시작하기' 라는 책을 스터디하기로 했다. 스터디는 이번에 활동하고 있는 YAPP 24기 스터디에서 진행한다.\n"},{"excerpt":"2. 아키텍쳐 개요 2.1 네 개의 영역 도메인 주도 설계(DDD)에서 아키텍처를 설계할 때 나타나는 전형적인 네 가지 영역 표현 영역 웹 애플리케이션에서 HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환하여 전달하고, 응용 영역의 응답을 HTTP 응답으로 변환하여 전송함. 응용 영역 시스템이 사용자에게 제공해야 할 기능을 구현함. 실제 비즈니스 로…","fields":{"slug":"/ddd-start-ch02/"},"frontmatter":{"date":"June 15, 2024","title":"도메인 주도 개발 시작하기 - 2장","tags":["DDD","study"]},"rawMarkdownBody":"\n# 2. 아키텍쳐 개요\n\n## 2.1 네 개의 영역\n\n도메인 주도 설계(DDD)에서 아키텍처를 설계할 때 나타나는 전형적인 네 가지 영역\n\n- **표현 영역**\n  - 웹 애플리케이션에서 HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환하여 전달하고, 응용 영역의 응답을 HTTP 응답으로 변환하여 전송함.\n- **응용 영역**\n  - 시스템이 사용자에게 제공해야 할 기능을 구현함.\n  - 실제 비즈니스 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임함.\n- **도메인 모델**\n  - 도메인의 핵심 로직을 구현함.\n- **인프라스트럭처 영역**\n  - 논리적인 개념을 표현하기보다는 실제 구현 기술 처리를 담당함.\n\n## 2.2 계층 구조 아키텍처\n\n계층 구조는 상위 계층에서 하위 계층으로의 의존만 존재하고, 하위 계층은 상위 계층에 의존하지 않음.\n\n- **문제점**: 표현, 응용, 도메인 계층이 인프라스트럭처 계층에 종속될 때 발생하는 문제\n  - **테스트**: 구현 방식에 종속되어 구현 방식 변경이 힘들어짐.\n  - **해결책**: DIP(의존 역전 원칙)를 통해 해결 가능\n\n## 2.3 DIP (Dependency Inversion Principle)\n\n고수준 모듈이 저수준 모듈을 사용하면 문제 발생. 저수준 모듈이 추상화한 인터페이스를 사용해서 고수준 모듈에 의존하게 해야 함. 이를 DIP(의존 역전 원칙)이라고 부름.\n\n- 상속은 의존의 다른 형태임.\n- 저수준 모듈에서 인터페이스를 추출하는 것은 의미가 없음. 도메인 관점에서 인터페이스를 도출해야 함.\n\n## 2.4 도메인 영역의 주요 구성요소\n\n- **엔티티 (ENTITY)**\n\n  - 고유의 식별자를 갖는 객체로, 자신의 라이프 사이클을 가짐. 도메인의 고유한 개념을 포함함.\n  - 단순히 데이터를 담고 있는 구조가 아니라, 데이터와 함께 도메인 기능을 제공하는 객체임.\n  - 도메인 관점에서 기능을 구현하고, 기능 구현을 캡슐화하여 데이터가 임의로 변경되는 것을 막음.\n  - 두 개 이상의 데이터가 개념적으로 하나인 경우, 밸류 타입을 이용해서 표현 가능.\n\n- **밸류 (VALUE)**\n\n  - 고유의 식별자를 갖지 않는 객체로, 주로 개념적으로 하나인 값을 의미함.\n  - 엔티티의 밸류 타입 데이터를 변경할 때는 객체 자체를 완전히 교체함.\n\n- **에그리거트 (AGGREGATE)**\n\n  - 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것임.\n  - 도메인 모델에서 전체 구조를 이해하는 데 도움이 됨.\n  - 루트 엔티티는 에그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 에그리거트가 구현해야 할 기능을 제공함.\n\n- **리포지터리 (REPOSITORY)**\n\n  - 에그리거트 단위로 도메인 모델의 영속성을 처리함.\n  - 응용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용함.\n  - 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술의 영향을 받음.\n\n- **도메인 서비스 (DOMAIN SERVICE)**\n  - 특정 엔티티에 속하지 않은 도메인 로직을 제공함.\n\n## 2.5 요청 처리 흐름\n\n- **표현 영역**\n\n  - 사용자가 전송한 데이터 형식이 올바른지 검사하고, 문제가 없다면 데이터를 이용해서 응용 서비스에 기능 실행을 위임함.\n  - 사용자가 전송한 데이터를 응용 서비스가 요구하는 형식으로 변환하여 전달함.\n\n- **응용 서비스 영역**\n  - 도메인 모델을 이용해서 기능을 구현함.\n\n## 2.6 인프라스트럭처 개요\n\n표현 영역, 응용 영역, 도메인 영역에 프레임워크, 구현 기술, 보조 기능을 지원함.\n\n고수준 인터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만듦.\n\n## 2.7 모듈 구성\n\n아키텍처의 각 영역은 별도 패키지에 위치함.\n\n도메인이 크면 하위 도메인으로 나누고, 각 하위 도메인마다 별도 패키지를 구성함.\n\n에그리거트, 모델, 리포지터리는 같은 패키지에 위치시키고, 한 패키지에 가능하면 10~15개 미만으로 타입 개수를 유지하려고 노력함.\n"},{"excerpt":"1. 도메인 모델 시작하기 1.1 도메인이란? 도메인: 소프트웨어로 해결하고자 하는 문제 영역 하나의 도메인은 여러 하위 도메인으로 나뉠 수 있음 예시: 온라인 서점 도메인 온라인 서점 소프트웨어는 상품조회, 구매, 결제, 배송 추적 등의 기능을 제공 '온라인 서점'은 소프트웨어로 해결하고자 하는 문제 영역, 즉 도메인에 해당됨 주문, 결제, 배송, 혜택…","fields":{"slug":"/ddd-start-ch01/"},"frontmatter":{"date":"June 14, 2024","title":"도메인 주도 개발 시작하기 - 1장","tags":["DDD","study"]},"rawMarkdownBody":"\n# 1. 도메인 모델 시작하기\n\n## 1.1 도메인이란?\n\n- **도메인**: 소프트웨어로 해결하고자 하는 문제 영역\n- 하나의 도메인은 여러 하위 도메인으로 나뉠 수 있음\n  - **예시**: 온라인 서점 도메인\n    - 온라인 서점 소프트웨어는 상품조회, 구매, 결제, 배송 추적 등의 기능을 제공\n    - '온라인 서점'은 소프트웨어로 해결하고자 하는 문제 영역, 즉 도메인에 해당됨\n    - 주문, 결제, 배송, 혜택 등 하위 도메인의 기능이 엮이게 됨\n\n## 1.2 도메인 전문가와 개발자 간 지식 공유\n\n- 개발자는 고객의 요구사항을 올바르게 이해하는 것이 중요\n  - 요구사항을 제대로 이해하지 못하면 코드 재작업이 많아짐 (Garbage in, Garbage out)\n  - 요구사항을 이해하기 위해 어느 정도의 도메인 지식을 갖춰야 함\n\n## 1.3 도메인 모델\n\n- **도메인 모델**: 특정 도메인을 개념적으로 표현한 것\n  - 도메인 모델을 통해 도메인이 어떤 기능을 수행할 수 있는지 이해 도움\n\n## 1.4 도메인 모델 패턴\n\n- 애플리케이션의 아키텍처는 계층구조를 가짐\n\n  | 영역                          | 설명                                                                                                      |\n  | ----------------------------- | --------------------------------------------------------------------------------------------------------- |\n  | 사용자 인터페이스 (표현 계층) | 사용자의 요청을 처리하고 응답하는 계층                                                                    |\n  | 응용 계층                     | 사용자가 요청한 기능을 수행하는 계층, 로직을 직접 구현하는 것이 아니라 도메인 계층을 조합해서 기능을 실행 |\n  | 도메인 계층                   | 시스템이 제공할 도메인 규칙을 구현하는 계층                                                               |\n  | 인프라스트럭처 계층           | 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리하는 계층                                  |\n\n- 도메인 규칙을 객체 지향 기법으로 구현하는 패턴이 **도메인 모델 패턴**임\n\n```java\npublic class Order {\n    private OrderState state;\n    private ShippingInfo shippinginfo;\n\n    public void changeShippingInfo(ShippingInfo newShippingInfo) {\n        if (!state.isShippingChangeable()) {\n            throw new IllegalStateException(\"can't change shipping in \" + state);\n        }\n        this.shippinginfo = newShippingInfo;\n    }\n\n    // ...\n}\n\npublic enum OrderState {\n    PAYMENT_WAITING {\n        public boolean isShippingChangeable() {\n            return true;\n        }\n    },\n    PREPARING {\n        public boolean isShippingChangeable() {\n            return true;\n        }\n    },\n    SHIPPED, DELIVERING, DELIVERY_COMPLETED;\n\n    public boolean isShippingChangeable() {\n        return false;\n    }\n}\n```\n\n- OrderState에는 주문 대기 중이거나 상품 준비 중에는 배송지를 변경할 수 있다는 도메인 규칙이 구현됨\n\n## 1.5 도메인 모델 도출\n\n- 코드를 작성하기 위해서는 먼저 도메인을 이해해야 함\n- 도메인을 모델링 할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것 (요구사항 분석)\n\n## 1.6 엔티티와 밸류\n\n- 도출한 모델은 크게 엔티티와 밸류로 구분할 수 있음\n- 엔티티와 밸류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있음\n\n## 1.6.1 엔티티\n\n- 엔티티의 가장 큰 특징은 식별자를 가짐\n  - 예: 주문 도메인에서 각 주문은 주문번호를 가짐\n\n## 1.6.2 엔티티의 식별자 생성\n\n- 특정 규칙에 따라 생성\n  - UUID, Nano ID\n  - 값 직접 입력\n  - 일련번호 사용 (시퀀스나 DB의 자동 증가 컬럼 사용)\n\n## 1.6.3 밸류 타입\n\n- 밸류 타입은 별도의 식별자가 없고, 객체 자체로 의미를 명확히 표현 가능\n  - 예: Address, Money 등\n- 예시: OrderLine에서 int 타입의 price와 amounts 필드를 밸류 타입인 Money 타입으로 대체\n\n```java\npublic class OrderLine {\n    private Product product;\n    private int price;\n    private int quantity;\n    private int amounts;\n}\n\npublic class OrderLine {\n    private Product product;\n    private Money price;\n    private int quantity;\n    private Money amounts;\n}\n```\n\n## 1.6.4 엔티티 식별자와 밸류 타입\n\n- 필드의 의미가 드러나도록 id 보다는 orderNo라는 명확한 필드 이름 사용\n\n## 1.6.5 도메인 모델에 set 메서드 넣지 않기\n\n- 명확한 이유가 없다면 setter 사용을 지양하고, 필요한 필드를 모두 포함하여 생성자로 강제\n- 도메인 객체가 불완전한 상태로 사용되는 것을 막을 수 있음\n\n## 1.7 도메인 용어와 유비쿼터스 언어\n\n- 도메인에서 사용하는 용어를 코드에 반영하여 코드만 읽어도 자연스럽게 이해할 수 있도록 함\n  - 예: Enum 사용시 STEP1, STEP2 보다는 READY, PAID 등 명확한 표현 사용\n"},{"excerpt":"Feature typeORM에서 연관관계가 없는 테이블 간 join 하는 방법 Tables User 테이블 Payment 테이블 각 테이블은 연관관계를 설정하지 않았고, payment 테이블에서 userId를 저장할 수 있게 했습니다. Join case 모든 user에 대한 payment 정보를 조회하기 위해 join을 합니다. 동작한 query 리턴된 …","fields":{"slug":"/typeorm-join/"},"frontmatter":{"date":"May 12, 2024","title":"연관관계 없이 join","tags":["nestjs","typeorm","database"]},"rawMarkdownBody":"\n# Feature\n\ntypeORM에서 연관관계가 없는 테이블 간 join 하는 방법\n\n## Tables\n\n### User 테이블\n\n<img width=\"1166\" alt=\"user_table\" src=\"https://github.com/EeeasyCode/nest-study/assets/92606611/f9416e58-37e1-4133-bdb5-b24399f40da9\">\n\n### Payment 테이블\n\n<img width=\"1179\" alt=\"payment_table\" src=\"https://github.com/EeeasyCode/nest-study/assets/92606611/06ef2ecf-9aaf-4b15-baa8-1f05877af87c\">\n\n각 테이블은 연관관계를 설정하지 않았고, payment 테이블에서 userId를 저장할 수 있게 했습니다.\n\n## Join case\n\n모든 user에 대한 payment 정보를 조회하기 위해 join을 합니다.\n\n```typescript\nasync leftJoin() {\n    return await this.usersRepository\n      .createQueryBuilder('user')\n      .leftJoinAndMapMany('user.payment', Payments, 'payment', 'user.id = payment.userId')\n      .getMany();\n}\n```\n\n### 동작한 query\n\n```shell\nquery: SELECT `user`.`id` AS `user_id`, `user`.`userEmail` AS `user_userEmail`, `user`.`password` AS `user_password`, `user`.`created_at` AS `user_created_at`, `user`.`updated_at` AS `user_updated_at`, `user`.`deleted_at` AS `user_deleted_at`, `payment`.`id` AS `payment_id`, `payment`.`userId` AS `payment_userId`, `payment`.`created_at` AS `payment_created_at`, `payment`.`updated_at` AS `payment_updated_at`, `payment`.`deleted_at` AS `payment_deleted_at` FROM `users` `user` LEFT JOIN `payments` `payment` ON  `user`.`id` = `payment`.`userId` AND `payment`.`deleted_at` IS NULL WHERE `user`.`deleted_at` IS NULL\n```\n\n### 리턴된 결과값\n\n```json\n[\n  {\n    \"id\": 1,\n    \"userEmail\": \"user1@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": [\n      {\n        \"id\": 4,\n        \"userId\": 1,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      },\n      {\n        \"id\": 1,\n        \"userId\": 1,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      }\n    ]\n  },\n  {\n    \"id\": 2,\n    \"userEmail\": \"user2@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": [\n      {\n        \"id\": 3,\n        \"userId\": 2,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      },\n      {\n        \"id\": 2,\n        \"userId\": 2,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      }\n    ]\n  },\n  {\n    \"id\": 3,\n    \"userEmail\": \"user3@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": [\n      {\n        \"id\": 5,\n        \"userId\": 3,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      }\n    ]\n  },\n  {\n    \"id\": 4,\n    \"userEmail\": \"user4@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": []\n  },\n  {\n    \"id\": 5,\n    \"userEmail\": \"user5@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": []\n  }\n]\n```\n"},{"excerpt":"Feature Image Upload 서버에서 Sharp 라이브러리를 사용해 Content-type 변경하는 기능 구현 Situation 기존 운영중인 서비스은 S3에 이미지 업로드 할 때, image/jpg로 업로드됩니다.\nJPG는 PNG에 비해 작은 용량의 크기로 사진을 압축할 수 있지만 WebP와 비교했을 때 화질면에서 크게 떨어집니다.\n또한, We…","fields":{"slug":"/nestjs-image-upload/"},"frontmatter":{"date":"April 03, 2024","title":"이미지 업로드 성능 개선","tags":["nestjs","성능 개선"]},"rawMarkdownBody":"\n# Feature\n\nImage Upload 서버에서 Sharp 라이브러리를 사용해 Content-type 변경하는 기능 구현\n\n## Situation\n\n기존 운영중인 서비스은 S3에 이미지 업로드 할 때, image/jpg로 업로드됩니다.\nJPG는 PNG에 비해 작은 용량의 크기로 사진을 압축할 수 있지만 WebP와 비교했을 때 화질면에서 크게 떨어집니다.\n또한, Webp는 PNG에 비해 크기가 26%, JPEG 이미지보다 25~34% 더 작습니다.\n\n> 출처 : https://developers.google.com/speed/webp?hl=ko\n\n## Task\n\n- 업로드 할 이미지의 용량 축소 기능 구현\n- Sharp 라이브러리를 활용하여 이미지의 Content-Type을 image/webp 로 변환\n\n## Action\n\n- 이미지 업로드 API의 서비스 로직에 Sharp 라이브러리로 Image의 Buffer를 webp로 변환\n- 이미지 파일의 확장자를 .webp로 변환\n- S3 업로드 시, ContentType을 image/webp로 설정\n\n## Result\n\n테스트 결과 -> 파일 A, 파일 B\n\n> png 파일 업로드 -> 131.2 KB, 333.5 KB <br>\n> jpeg 파일 업로드 -> 86.0 KB, 241.8 KB <br> > **webp 파일 업로드 -> 50.9 KB, 128.2 KB** <br>\n\n로 webp 변환 시 저장 공간에 대한 효율성을 향상시킬 수 있습니다.\n이는 업로드에 대한 성능 뿐만 아니라, 실제 클라이언트에게 이미지 파일이 전달될 때에 확실한 성능 차이가 보여질 것으로 판단됩니다.\n\n<img width=\"1157\" alt=\"upload_test\" src=\"https://github.com/EeeasyCode/nest-study/assets/92606611/e605cf3b-8069-44bd-922d-dc6e3e5d9235\">\n"},{"excerpt":"Tech Environment Python v3.12 actions/checkout@v3 actions/setup-python@v3 python code의 의존성을 위해 requirements.txt로 라이브러리 설치 member_list.json 해당 파일에 멤버 리스트를 등록하여 사용합니다. 이와 같은 형식으로 등록합니다. PR notificaiton…","fields":{"slug":"/github-slack-bot/"},"frontmatter":{"date":"February 27, 2024","title":"PR 리뷰어 할당 봇 만들기","tags":["github-action","자동화"]},"rawMarkdownBody":"\n## Tech Environment\n\n- Python v3.12\n- actions/checkout@v3\n- actions/setup-python@v3\n- python code의 의존성을 위해 requirements.txt로 라이브러리 설치\n\n## member_list.json\n\n해당 파일에 멤버 리스트를 등록하여 사용합니다.\n\n```json\n[\n  {\n    \"githubName\": \"CEethan\",\n    \"slackUserId\": \"U069RPHRU95\"\n  },\n  {\n    \"githubName\": \"EeeasyCode\",\n    \"slackUserId\": \"U069RPHRU95\"\n  }\n]\n```\n\n이와 같은 형식으로 등록합니다.\n\n---\n\n## PR notificaiton bot\n\n> 지정한 레포지토리의 PR이 남아있는지 확인 후, 평일 지정한 시간에 Slack을 통해 알림을 전송하는 Bot 입니다.\n\n### Code Description\n\n### pr-notification.py\n\n- python 코드로 slack, github 연동\n- github repository 정보를 가져와 slack 메시지 형태로 가공\n- 가공된 메시지를 지정한 slack 채널로 전송\n\n### pr-notification-bot.yml\n\n- schedule -> cron 표현식을 통해 지정한 시간마다 동작하도록\n  스케줄링\n- 이후, github secret을 사용해 env 값 설정\n- github action을 활용하여 pr-notification.py를 실행\n\n---\n\n## assign reviewer bot\n\n> PR을 올리면 랜덤으로 리뷰어가 할당되어 Slack을 통해 알림받을 수 있습니다.\n\n### Code Description\n\n### assign-reviewer.py\n\n- python 코드로 slack, github 연동\n- python 내부 로직에 의해, 자동으로 리뷰어를 할당하여 등록함\n- 리뷰어로 할당된 멤버에게 Slack 메시지 전송\n\n### assign-reviewer-bot.yml\n\n- PR 이벤트를 감지하여 PR이 올라올 경우 해당 action 트리거\n- 이후, github secret을 사용해 env 값 설정\n- github action을 활용하여 assign-reviewer.py를 실행\n\n---\n\n## review check bot\n\n> 리뷰어가 PR에 대한 리뷰를 완료하면 PR 담당자에게 Slack 메시지를 전송합니다.\n\n### Code Description\n\n### review-check.py\n\n- python 코드로 slack, github 연동\n- python 내부 로직에 의해 PR 담당자에게 리뷰가 되었음을 알림\n\n### review-check-bot.yml\n\n- PR의 리뷰 이벤트를 감지하여 리뷰가 등록된 경우 해당 action\n  트리거\n- 이후, github secret을 사용해 env 값 설정\n- github action을 활용하여 review-check.py를 실행\n"},{"excerpt":"동시에 같은 DB 테이블 row를 업데이트 하는 상황은 \"DB의 동시성 이슈\"으로 생각해보면 좋을 것 같다. DB의 동시성 이슈 동시성이란 여러 요청이 동시에 동일한 자원(Data)에 접근하고 수정하려는 것을 말한다. 이로 인해, 발생하게 되는 문제를 동시성 문제라고 한다. 동시성 문제로 Data의 무결성이 깨지고 의도하지 않은 결과를 반환하게 되는 문제…","fields":{"slug":"/concurrency-issue/"},"frontmatter":{"date":"February 16, 2024","title":"동시성 이슈 해결해보기","tags":["database","문제해결"]},"rawMarkdownBody":"\n동시에 같은 DB 테이블 row를 업데이트 하는 상황은 <Strong>\"DB의 동시성 이슈\"</Strong>으로 생각해보면 좋을 것 같다.\n\n# DB의 동시성 이슈\n\n<Strong>동시성</Strong>이란 여러 요청이 동시에 동일한 자원(Data)에 접근하고 수정하려는 것을 말한다. 이로 인해, 발생하게 되는 문제를 동시성 문제라고 한다. 동시성 문제로 Data의 무결성이 깨지고 의도하지 않은 결과를 반환하게 되는 문제들이 발생한다.\n\n<hr>\n\n# 해결방안\n\n해결방안에는 DB수준에서의 락, 프레임워크 or 언어 수준에서의 동기화 등이 존재한다. 여기서는 DB수준에서의 락에 대해 알아보려고 한다.\n\n> 1. 테이블의 row에 접근 시, Lock을 걸고 다른 Lock이 걸려있지 않는 경우에만 수정을 가능하게 함\n> 2. 수정할 때 내가 먼저 수정했음을 명시하여 다른 곳에서 동일한 조건으로 값을 수정할 수 없게 함\n\n위처럼, 자원 경쟁에 대한 관점으로 두 가지의 방법을 생각해볼 수 있다. 이는 비관적 락과 낙관적 락을 나누는 기준이 된다.\n\n<hr>\n\n## 비관적 락(Pessimistic Lock)\n\n현재 수정하려는 data가 언제든지 다른 요청에 의해 수정될 가능성을 고려하여 해당 data에 Lock을 거는 방식\n트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작한다.\n\n- <code><Strong>공유락 (Shared Lock)</Strong></code> : Read Lock이라고 하는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만 하기 때문에 같은 공유락끼리는 동시에 접근이 가능하지만, 쓰기 작업은 막는다.\n\n- <code><Strong>베타락 (Exclusive Lock)</Strong></code> : Write Lock이라고 하는 배터락은, 데이터를 변경할 때 사용하는 락이다. 트랜잭션이 완료될 때까지 유지되며, 락이 끝나기 전까지 읽기/쓰기를 모두 막는다.\n\n### 장점\n\n- data의 무결성을 보존할 수 있다.\n- 충돌 발생 미리 방지\n\n### 단점\n\n- Lock으로 인해 이후의 다른 요청은 대기 상태로 빠짐\n- 기존 Lock의 트랜잭션이 commit/rollback으로 끝내면 이후 대기 요청을 실행\n\n<hr>\n\n## 낙관적 락(Optimistic Lock)\n\n자원에 락을 걸지 않고, 동시성 문제가 발생하면 그때 처리한다.\n숫자/시간 컬럼을 만들어 수정 시 그 data를 증가/갱신함 -> data 수정 시 컬럼을 비교하여 일치하는지 확인\n\n- Version과 같은 <Strong>별도의 컬럼을 추가</Strong>하여 충돌 발생을 막는다.\n  Version -> hashcode / timestamp 등을 사용하여 상태를 보고 충돌 확인함\n\n- 충돌 발생 시, DB가 아닌 애플리케이션 단에서 처리를 한다.\n  낙관적 락은 UPDATE에 실패해도 자동으로 예외를 던지지 않고, 단순히 0개의 row를 업데이트한다.\n  따라서 이때 여러 작업이 묶은 트랜잭션 요청 실패 시,<Strong>우리가 직접 롤백 처리</Strong>를 해줘야 한다.\n\n### 장점\n\n- 구현하기 용이함\n- 지속적인 락으로 인한 성능저하를 막을 수 있음\n\n### 단점\n\n- Version Conflict 시, 처리해야 할 외부 요인이 존재함\n\n<hr>\n\n## 성능 비교\n\n> <Strong>비관적 락 < 낙관적 락 </Strong>\n\n- 낙관적 락은 트랜잭션이 필요하지 않기 때문에 성능적으로 우수함\n- 비관적 락은 데이터 자체에 락을 걸기 때문에 동시성이 떨어져 성능 저하가 발생하며, 서로의 자원이 필요할 경우에는 교착상태가 발생할 가능성 존재\n\n> <Strong>충돌이 많이 발생하는 환경</Strong>\n\n충돌 발생 시, 비관적 락은 트랜잭션을 롤백하면 끝남. 하지만 낙관적 락은 까다로운 수동 롤백 처리와 성능 측면에서도 Update를 한번씩 더 해줘야 하기 떄문에, 성능 저하가 발생할 수 있음\n\n<Strong> 데이터의 무결성 + 데이터의 충돌이 많이 발생할 것 같은 경우 -> 비관적 락\n데이터 충돌이 적을 것 같은 경우 + 조회 작업이 많아 동시 접근 성능이 중요 -> 낙관적 락 </Strong>\n"},{"excerpt":"이번에 진행한 프로젝트에서 나는 CloudType을 사용하여 NestJS 기반 서버를 무료로 배포하였다. 무료로 서버를 배포할 수 있다는 것이 정말 큰 장점이었지만, CloudType의 무료 티어의 경우 연속 실행 제한이 걸려 매일 오전 3~9시 사이 프리티어로 구동 중인 서비스는 자동으로 중지 상태로 변경되는 문제가 존재한다.  사실, 정지되는 것은 문…","fields":{"slug":"/github-healthcheck-bot/"},"frontmatter":{"date":"December 27, 2023","title":"github-action + slack으로 서버 헬스체크하기","tags":["github-action","자동화"]},"rawMarkdownBody":"\n이번에 진행한 프로젝트에서 나는 CloudType을 사용하여 NestJS 기반 서버를 무료로 배포하였다. 무료로 서버를 배포할 수 있다는 것이 정말 큰 장점이었지만, CloudType의 무료 티어의 경우 **연속 실행 제한**이 걸려 매일 오전 3~9시 사이 프리티어로 구동 중인 서비스는 자동으로 중지 상태로 변경되는 문제가 존재한다.\n\n![](https://velog.velcdn.com/images/eeeasy-code/post/227fe906-018a-41b5-92e3-25f37f0a37c8/image.png)\n\n사실, 정지되는 것은 문제가 되지 않았다. 웹 사이트에 접속하는 사용자의 수도 많지 않았고, 오전 3~9시 사이에 접속하는 사용자는 더욱 낮을 것이라고 판단했기 때문이다. 그럼에도 일단 언제 중지될지 모르는 서버와 꺼져있는 서버를 재가동시키는 것을 깜빡하는 경우에 소중한 사용자의 데이터가 저장되지 못하는 일이 발생했다. 프로젝트 배포에서 가장 중요했던 사용자의 구매량과 버튼 클릭 수를 DB 서버에 저장하고 있었기에 이는 우리에게 나름 크리티컬한 문제가 되었다.\n\n## 대응 방안\n\n일단 초기 대응 방안은 그저 9시 이후에 CloudType 프로젝트 관리창에서 꺼져있는 나의 서버를 다시 켰다. 그런데 가끔 9시 이후에도 잘 켜져있다가 이후에 꺼지는 경우도 있었던 것으로 기억한다. 그래서, 언제꺼질지 몰라 지속적으로 확인했었다. 이는 너무 귀찮기도 했고 짜증나기도 했다. 그렇게 점점 서버 재가동을 놓치는 시간이 많아졌고, 서버는 잠들어 있는 시간이 더 길어졌다.\n\n문제를 해결하기 위해, 아이디어를 구상해 보았다.\n\n> 1. 서버 중단 시, 내부 로직에 중단되기 직전 메일 등의 알림 기능을 구현\n> 2. 프론트엔드 단에서 서버의 응답이 정상적으로 오지않을 경우를 확인\n> 3. 헬스체크 서버를 구현 후 배포하여 주기적으로 확인\n\n내 머리 속에 든 생각은 총 3가지였다. 우선 첫 번째 아이디어를 진행보았다. 서버 내부 메인 로직에 아래와 같은 코드를 넣어 서버가 다운될 시점에 로그 파일을 남길 수 있도록 진행했다.\n\n```\nprocess.on('exit', code => {\n  console.log(code)\n  logger.log({\n    level: 'error',\n    message: 'exit'\n  })\n})\n\nprocess.on('SIGINT', code => {\n  console.log(code)\n  logger.log({\n    level: 'error',\n    message: 'sigint'\n  })\n})\n```\n\n하지만, 서버가 중단되고 재가동 후 확인해본 결과 로그 파일은 생성되지 않았다. 그 원인에 대해 아직도 명확한 해답을 찾지는 못했지만 스스로 생각해본 결과 배포 시스템이 중단되는 것과 내부 로직은 관련이 없고, AWS처럼 시스템 중단 시 발생하는 이벤트가 존재할텐데 이를 활용해야 할 것 같다는 생각이 들었다. CloudType 공식문서에는 따로 나와있는 내용이 없었다.\n\n두 번째 아이디어는 프론트엔드 단에서 내가 배포한 서버의 API를 호출했을 때, 응답이 정상적으로 오지않고 500 등의 에러를 응답할 경우에 알림을 보내는 기능을 생각해봤다. 사실 이 아이디어도 나름 깔끔하고 좋다고 생각했지만, 프론트엔드 개발자 분께서 본인의 코드를 건드는 것을 별로 좋아하지 않았고 그래서 일단 내가 스스로 해결해보려 노력해봤다.\n\n마지막 아이디어를 지금 채택해 사용 중인데, 초기에 생각했던 것은 헬스체크 서버에 기존 서버의 헬스체크 Api를 스케줄링하는 기능을 구현해 배포하려고 했다. 생각해보니 그럼 서버가 두 개나 띄워져있는 것인데 이는 낭비라고 생각이 들었다. 그래서 찾은 방법이 ** Github Action으로 헬스 체크**하는 것이었다. Github Action으로 스케줄링을 걸어놓고 특정 시간에 한 번씩 서버의 상태를 확인하고, 이를 Slack으로 알림을 전송하는 것을 생각했다.\n\n## Github Action으로 헬스체크\n\ngithub action에 등록한 헬스체크 기능을 코드로 먼저 보겠다.\n\n```\nname: health check\n\non:\n  # 스케줄링을 설정함 / 매분마다 한 번씩 이벤트를 트리거함\n  schedule:\n    - cron: '*/1 * * * *'\n  # workflow_dispath는 수동으로 이벤트를 트리거할 수 있도록 해주는 것을 의미함\n  workflow_dispatch:\n\njobs:\n  healthcheck:\n    runs-on: ubuntu-latest\n    steps:\n      # 지정한 서버에 대해 헬스 체크 진행\n      - name: Release API Health Check\n        uses: jtalk/url-health-check-action@v3\n        with:\n          github_token: ${{ secrets.GHP_TOKEN }}\n          url: ${{ secrets.RELEASE_URI }}\n          max-attempts: 3 # 시도 횟수\n          retry-delay: 1s # 시도 간격\n\n\t  # 트리거된 이벤트의 내용을 slack으로 전달\n      - name: action-slack\n        uses: 8398a7/action-slack@v3\n        with:\n          status: ${{ job.status }}\n          github_token: ${{ secrets.GHP_TOKEN }}\n          author_name: Github Action Health Check\n          fields: repo,message,commit,action,eventName,ref,workflow,job,took # 보낼 정보들\n        env:\n          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEB_HOOK_URL }}\n        if: always() # 특정 조건에 상관없이 항상 실행\n\n```\n\n작성된 github action의 healthCheck 플로우는 다음과 같다. 이 후, slack의 incoming-webhook을 등록하여 진행하면 문제없이 서버의 healthCheck 기능이 정상적으로 작동된다. 덕분에 서버가 중단된 경우 Slack을 통해 알림을 받을 수 있게 되었고, 귀찮게 내가 한번씩 접속해서 서버가 중단되었는지 확인하지 않아도 알 수 있게 되어 너무 편하다.\n\n| 서버 정상 작동                                                                                       | 서버 중단 시                                                                                         |\n| ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |\n| ![](https://velog.velcdn.com/images/eeeasy-code/post/2ff2fd43-d7ec-4cb7-98b4-1618a3ac1b7b/image.png) | ![](https://velog.velcdn.com/images/eeeasy-code/post/0db7fdfe-7582-4679-bd0c-eb87353f6925/image.png) |\n\n![](https://velog.velcdn.com/images/eeeasy-code/post/81ed5cf4-526b-4085-98c3-9d4c04d9a76e/image.png)\n\n## 발생한 문제들\n\n1. Github Action에서 발생하는 <code>\"Resource not accessible by integration\"</code> 문제 발생 -> github token을 넣어주면 해결 가능\n2. <code>\"The process '/usr/bin/git' failed with exit code 1\"</code> 문제 발생 -> healthCheck할 서버의 url이 정상적인 응답을 보내는지 확인 후 설정\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}