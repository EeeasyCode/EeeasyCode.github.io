{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"Feature typeORM에서 연관관계가 없는 테이블 간 join 하는 방법 Tables User 테이블 Payment 테이블 각 테이블은 연관관계를 설정하지 않았고, payment 테이블에서 userId를 저장할 수 있게 했습니다. Join case 모든 user에 대한 payment 정보를 조회하기 위해 join을 합니다. 동작한 query 리턴된 …","fields":{"slug":"/typeorm-join/"},"frontmatter":{"date":"May 12, 2024","title":"연관관계 없이 join","tags":["nestjs","typeorm","database"]},"rawMarkdownBody":"\n# Feature\n\ntypeORM에서 연관관계가 없는 테이블 간 join 하는 방법\n\n## Tables\n\n### User 테이블\n\n<img width=\"1166\" alt=\"user_table\" src=\"https://github.com/EeeasyCode/nest-study/assets/92606611/f9416e58-37e1-4133-bdb5-b24399f40da9\">\n\n### Payment 테이블\n\n<img width=\"1179\" alt=\"payment_table\" src=\"https://github.com/EeeasyCode/nest-study/assets/92606611/06ef2ecf-9aaf-4b15-baa8-1f05877af87c\">\n\n각 테이블은 연관관계를 설정하지 않았고, payment 테이블에서 userId를 저장할 수 있게 했습니다.\n\n## Join case\n\n모든 user에 대한 payment 정보를 조회하기 위해 join을 합니다.\n\n```typescript\nasync leftJoin() {\n    return await this.usersRepository\n      .createQueryBuilder('user')\n      .leftJoinAndMapMany('user.payment', Payments, 'payment', 'user.id = payment.userId')\n      .getMany();\n}\n```\n\n### 동작한 query\n\n```shell\nquery: SELECT `user`.`id` AS `user_id`, `user`.`userEmail` AS `user_userEmail`, `user`.`password` AS `user_password`, `user`.`created_at` AS `user_created_at`, `user`.`updated_at` AS `user_updated_at`, `user`.`deleted_at` AS `user_deleted_at`, `payment`.`id` AS `payment_id`, `payment`.`userId` AS `payment_userId`, `payment`.`created_at` AS `payment_created_at`, `payment`.`updated_at` AS `payment_updated_at`, `payment`.`deleted_at` AS `payment_deleted_at` FROM `users` `user` LEFT JOIN `payments` `payment` ON  `user`.`id` = `payment`.`userId` AND `payment`.`deleted_at` IS NULL WHERE `user`.`deleted_at` IS NULL\n```\n\n### 리턴된 결과값\n\n```json\n[\n  {\n    \"id\": 1,\n    \"userEmail\": \"user1@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": [\n      {\n        \"id\": 4,\n        \"userId\": 1,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      },\n      {\n        \"id\": 1,\n        \"userId\": 1,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      }\n    ]\n  },\n  {\n    \"id\": 2,\n    \"userEmail\": \"user2@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": [\n      {\n        \"id\": 3,\n        \"userId\": 2,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      },\n      {\n        \"id\": 2,\n        \"userId\": 2,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      }\n    ]\n  },\n  {\n    \"id\": 3,\n    \"userEmail\": \"user3@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": [\n      {\n        \"id\": 5,\n        \"userId\": 3,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      }\n    ]\n  },\n  {\n    \"id\": 4,\n    \"userEmail\": \"user4@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": []\n  },\n  {\n    \"id\": 5,\n    \"userEmail\": \"user5@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": []\n  }\n]\n```\n"},{"excerpt":"Feature Image Upload 서버에서 Sharp 라이브러리를 사용해 Content-type 변경하는 기능 구현 Situation 기존 운영중인 서비스은 S3에 이미지 업로드 할 때, image/jpg로 업로드됩니다.\nJPG는 PNG에 비해 작은 용량의 크기로 사진을 압축할 수 있지만 WebP와 비교했을 때 화질면에서 크게 떨어집니다.\n또한, We…","fields":{"slug":"/image-upload/"},"frontmatter":{"date":"April 03, 2024","title":"이미지 업로드 성능 개선","tags":["nestjs","성능 개선"]},"rawMarkdownBody":"\n# Feature\n\nImage Upload 서버에서 Sharp 라이브러리를 사용해 Content-type 변경하는 기능 구현\n\n## Situation\n\n기존 운영중인 서비스은 S3에 이미지 업로드 할 때, image/jpg로 업로드됩니다.\nJPG는 PNG에 비해 작은 용량의 크기로 사진을 압축할 수 있지만 WebP와 비교했을 때 화질면에서 크게 떨어집니다.\n또한, Webp는 PNG에 비해 크기가 26%, JPEG 이미지보다 25~34% 더 작습니다.\n\n> 출처 : https://developers.google.com/speed/webp?hl=ko\n\n## Task\n\n- 업로드 할 이미지의 용량 축소 기능 구현\n- Sharp 라이브러리를 활용하여 이미지의 Content-Type을 image/webp 로 변환\n\n## Action\n\n- 이미지 업로드 API의 서비스 로직에 Sharp 라이브러리로 Image의 Buffer를 webp로 변환\n- 이미지 파일의 확장자를 .webp로 변환\n- S3 업로드 시, ContentType을 image/webp로 설정\n\n## Result\n\n테스트 결과 -> 파일 A, 파일 B\n\n> png 파일 업로드 -> 131.2 KB, 333.5 KB <br>\n> jpeg 파일 업로드 -> 86.0 KB, 241.8 KB <br> > **webp 파일 업로드 -> 50.9 KB, 128.2 KB** <br>\n\n로 webp 변환 시 저장 공간에 대한 효율성을 향상시킬 수 있습니다.\n이는 업로드에 대한 성능 뿐만 아니라, 실제 클라이언트에게 이미지 파일이 전달될 때에 확실한 성능 차이가 보여질 것으로 판단됩니다.\n\n<img width=\"1157\" alt=\"upload_test\" src=\"https://github.com/EeeasyCode/nest-study/assets/92606611/e605cf3b-8069-44bd-922d-dc6e3e5d9235\">\n"},{"excerpt":"Tech Environment Python v3.12 actions/checkout@v3 actions/setup-python@v3 python code의 의존성을 위해 requirements.txt로 라이브러리 설치 member_list.json 해당 파일에 멤버 리스트를 등록하여 사용합니다. 이와 같은 형식으로 등록합니다. PR notificaiton…","fields":{"slug":"/github-slack-bot/"},"frontmatter":{"date":"February 27, 2024","title":"PR 리뷰어 할당 봇 만들기","tags":["github-action","자동화"]},"rawMarkdownBody":"\n## Tech Environment\n\n- Python v3.12\n- actions/checkout@v3\n- actions/setup-python@v3\n- python code의 의존성을 위해 requirements.txt로 라이브러리 설치\n\n## member_list.json\n\n해당 파일에 멤버 리스트를 등록하여 사용합니다.\n\n```json\n[\n  {\n    \"githubName\": \"CEethan\",\n    \"slackUserId\": \"U069RPHRU95\"\n  },\n  {\n    \"githubName\": \"EeeasyCode\",\n    \"slackUserId\": \"U069RPHRU95\"\n  }\n]\n```\n\n이와 같은 형식으로 등록합니다.\n\n---\n\n## PR notificaiton bot\n\n> 지정한 레포지토리의 PR이 남아있는지 확인 후, 평일 지정한 시간에 Slack을 통해 알림을 전송하는 Bot 입니다.\n\n### Code Description\n\n### pr-notification.py\n\n- python 코드로 slack, github 연동\n- github repository 정보를 가져와 slack 메시지 형태로 가공\n- 가공된 메시지를 지정한 slack 채널로 전송\n\n### pr-notification-bot.yml\n\n- schedule -> cron 표현식을 통해 지정한 시간마다 동작하도록\n  스케줄링\n- 이후, github secret을 사용해 env 값 설정\n- github action을 활용하여 pr-notification.py를 실행\n\n---\n\n## assign reviewer bot\n\n> PR을 올리면 랜덤으로 리뷰어가 할당되어 Slack을 통해 알림받을 수 있습니다.\n\n### Code Description\n\n### assign-reviewer.py\n\n- python 코드로 slack, github 연동\n- python 내부 로직에 의해, 자동으로 리뷰어를 할당하여 등록함\n- 리뷰어로 할당된 멤버에게 Slack 메시지 전송\n\n### assign-reviewer-bot.yml\n\n- PR 이벤트를 감지하여 PR이 올라올 경우 해당 action 트리거\n- 이후, github secret을 사용해 env 값 설정\n- github action을 활용하여 assign-reviewer.py를 실행\n\n---\n\n## review check bot\n\n> 리뷰어가 PR에 대한 리뷰를 완료하면 PR 담당자에게 Slack 메시지를 전송합니다.\n\n### Code Description\n\n### review-check.py\n\n- python 코드로 slack, github 연동\n- python 내부 로직에 의해 PR 담당자에게 리뷰가 되었음을 알림\n\n### review-check-bot.yml\n\n- PR의 리뷰 이벤트를 감지하여 리뷰가 등록된 경우 해당 action\n  트리거\n- 이후, github secret을 사용해 env 값 설정\n- github action을 활용하여 review-check.py를 실행\n"},{"excerpt":"이번에 진행한 프로젝트에서 나는 CloudType을 사용하여 NestJS 기반 서버를 무료로 배포하였다. 무료로 서버를 배포할 수 있다는 것이 정말 큰 장점이었지만, CloudType의 무료 티어의 경우 연속 실행 제한이 걸려 매일 오전 3~9시 사이 프리티어로 구동 중인 서비스는 자동으로 중지 상태로 변경되는 문제가 존재한다.  사실, 정지되는 것은 문…","fields":{"slug":"/github-healthcheck-bot/"},"frontmatter":{"date":"December 27, 2023","title":"github-action + slack으로 서버 헬스체크하기","tags":["github-action","자동화"]},"rawMarkdownBody":"\n이번에 진행한 프로젝트에서 나는 CloudType을 사용하여 NestJS 기반 서버를 무료로 배포하였다. 무료로 서버를 배포할 수 있다는 것이 정말 큰 장점이었지만, CloudType의 무료 티어의 경우 **연속 실행 제한**이 걸려 매일 오전 3~9시 사이 프리티어로 구동 중인 서비스는 자동으로 중지 상태로 변경되는 문제가 존재한다.\n\n![](https://velog.velcdn.com/images/eeeasy-code/post/227fe906-018a-41b5-92e3-25f37f0a37c8/image.png)\n\n사실, 정지되는 것은 문제가 되지 않았다. 웹 사이트에 접속하는 사용자의 수도 많지 않았고, 오전 3~9시 사이에 접속하는 사용자는 더욱 낮을 것이라고 판단했기 때문이다. 그럼에도 일단 언제 중지될지 모르는 서버와 꺼져있는 서버를 재가동시키는 것을 깜빡하는 경우에 소중한 사용자의 데이터가 저장되지 못하는 일이 발생했다. 프로젝트 배포에서 가장 중요했던 사용자의 구매량과 버튼 클릭 수를 DB 서버에 저장하고 있었기에 이는 우리에게 나름 크리티컬한 문제가 되었다.\n\n## 대응 방안\n\n일단 초기 대응 방안은 그저 9시 이후에 CloudType 프로젝트 관리창에서 꺼져있는 나의 서버를 다시 켰다. 그런데 가끔 9시 이후에도 잘 켜져있다가 이후에 꺼지는 경우도 있었던 것으로 기억한다. 그래서, 언제꺼질지 몰라 지속적으로 확인했었다. 이는 너무 귀찮기도 했고 짜증나기도 했다. 그렇게 점점 서버 재가동을 놓치는 시간이 많아졌고, 서버는 잠들어 있는 시간이 더 길어졌다.\n\n문제를 해결하기 위해, 아이디어를 구상해 보았다.\n\n> 1. 서버 중단 시, 내부 로직에 중단되기 직전 메일 등의 알림 기능을 구현\n> 2. 프론트엔드 단에서 서버의 응답이 정상적으로 오지않을 경우를 확인\n> 3. 헬스체크 서버를 구현 후 배포하여 주기적으로 확인\n\n내 머리 속에 든 생각은 총 3가지였다. 우선 첫 번째 아이디어를 진행보았다. 서버 내부 메인 로직에 아래와 같은 코드를 넣어 서버가 다운될 시점에 로그 파일을 남길 수 있도록 진행했다.\n\n```\nprocess.on('exit', code => {\n  console.log(code)\n  logger.log({\n    level: 'error',\n    message: 'exit'\n  })\n})\n\nprocess.on('SIGINT', code => {\n  console.log(code)\n  logger.log({\n    level: 'error',\n    message: 'sigint'\n  })\n})\n```\n\n하지만, 서버가 중단되고 재가동 후 확인해본 결과 로그 파일은 생성되지 않았다. 그 원인에 대해 아직도 명확한 해답을 찾지는 못했지만 스스로 생각해본 결과 배포 시스템이 중단되는 것과 내부 로직은 관련이 없고, AWS처럼 시스템 중단 시 발생하는 이벤트가 존재할텐데 이를 활용해야 할 것 같다는 생각이 들었다. CloudType 공식문서에는 따로 나와있는 내용이 없었다.\n\n두 번째 아이디어는 프론트엔드 단에서 내가 배포한 서버의 API를 호출했을 때, 응답이 정상적으로 오지않고 500 등의 에러를 응답할 경우에 알림을 보내는 기능을 생각해봤다. 사실 이 아이디어도 나름 깔끔하고 좋다고 생각했지만, 프론트엔드 개발자 분께서 본인의 코드를 건드는 것을 별로 좋아하지 않았고 그래서 일단 내가 스스로 해결해보려 노력해봤다.\n\n마지막 아이디어를 지금 채택해 사용 중인데, 초기에 생각했던 것은 헬스체크 서버에 기존 서버의 헬스체크 Api를 스케줄링하는 기능을 구현해 배포하려고 했다. 생각해보니 그럼 서버가 두 개나 띄워져있는 것인데 이는 낭비라고 생각이 들었다. 그래서 찾은 방법이 ** Github Action으로 헬스 체크**하는 것이었다. Github Action으로 스케줄링을 걸어놓고 특정 시간에 한 번씩 서버의 상태를 확인하고, 이를 Slack으로 알림을 전송하는 것을 생각했다.\n\n## Github Action으로 헬스체크\n\ngithub action에 등록한 헬스체크 기능을 코드로 먼저 보겠다.\n\n```\nname: health check\n\non:\n  # 스케줄링을 설정함 / 매분마다 한 번씩 이벤트를 트리거함\n  schedule:\n    - cron: '*/1 * * * *'\n  # workflow_dispath는 수동으로 이벤트를 트리거할 수 있도록 해주는 것을 의미함\n  workflow_dispatch:\n\njobs:\n  healthcheck:\n    runs-on: ubuntu-latest\n    steps:\n      # 지정한 서버에 대해 헬스 체크 진행\n      - name: Release API Health Check\n        uses: jtalk/url-health-check-action@v3\n        with:\n          github_token: ${{ secrets.GHP_TOKEN }}\n          url: ${{ secrets.RELEASE_URI }}\n          max-attempts: 3 # 시도 횟수\n          retry-delay: 1s # 시도 간격\n\n\t  # 트리거된 이벤트의 내용을 slack으로 전달\n      - name: action-slack\n        uses: 8398a7/action-slack@v3\n        with:\n          status: ${{ job.status }}\n          github_token: ${{ secrets.GHP_TOKEN }}\n          author_name: Github Action Health Check\n          fields: repo,message,commit,action,eventName,ref,workflow,job,took # 보낼 정보들\n        env:\n          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEB_HOOK_URL }}\n        if: always() # 특정 조건에 상관없이 항상 실행\n\n```\n\n작성된 github action의 healthCheck 플로우는 다음과 같다. 이 후, slack의 incoming-webhook을 등록하여 진행하면 문제없이 서버의 healthCheck 기능이 정상적으로 작동된다. 덕분에 서버가 중단된 경우 Slack을 통해 알림을 받을 수 있게 되었고, 귀찮게 내가 한번씩 접속해서 서버가 중단되었는지 확인하지 않아도 알 수 있게 되어 너무 편하다.\n\n| 서버 정상 작동                                                                                       | 서버 중단 시                                                                                         |\n| ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |\n| ![](https://velog.velcdn.com/images/eeeasy-code/post/2ff2fd43-d7ec-4cb7-98b4-1618a3ac1b7b/image.png) | ![](https://velog.velcdn.com/images/eeeasy-code/post/0db7fdfe-7582-4679-bd0c-eb87353f6925/image.png) |\n\n![](https://velog.velcdn.com/images/eeeasy-code/post/81ed5cf4-526b-4085-98c3-9d4c04d9a76e/image.png)\n\n## 발생한 문제들\n\n1. Github Action에서 발생하는 <code>\"Resource not accessible by integration\"</code> 문제 발생 -> github token을 넣어주면 해결 가능\n2. <code>\"The process '/usr/bin/git' failed with exit code 1\"</code> 문제 발생 -> healthCheck할 서버의 url이 정상적인 응답을 보내는지 확인 후 설정\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}