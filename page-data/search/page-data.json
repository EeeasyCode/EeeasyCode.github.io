{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"분산 트랜잭션 분산 트랜잭션은 쉽게 설명해서 데이터베이스의 트랜잭션이 하나가 아닌, 분산으로 발생하는 것을 말한다.\n가령, 하나의 서버에서 서로 다른 DB를 사용하여 하나의 작업을 묶는 등 여러 리소스에 영향을 주는 트랜잭션처럼 말이다. 우선, 두 가지의 케이스를 고려해본다.  Monolithic 환경에서 DB 리소스가 1개인 경우\nimg 대부분 Mono…","fields":{"slug":"/distributed-transaction/"},"frontmatter":{"date":"September 05, 2024","title":"분산 트랜잭션","tags":["Database","MSA"]},"rawMarkdownBody":"\n# 분산 트랜잭션\n분산 트랜잭션은 쉽게 설명해서 데이터베이스의 트랜잭션이 하나가 아닌, 분산으로 발생하는 것을 말한다.\n가령, 하나의 서버에서 서로 다른 DB를 사용하여 하나의 작업을 묶는 등 여러 리소스에 영향을 주는 트랜잭션처럼 말이다.\n\n우선, 두 가지의 케이스를 고려해본다. \n\n**Monolithic 환경에서 DB 리소스가 1개인 경우**\n![img](https://eeeasycode.github.io/src/images/monolithic.png)\n\n대부분 Monolithic 구조에서 1개의 DB 만을 사용하는 경우가 대부분이다. 그래서 각 서비스가 접근해 발생하는 트랜잭션을 하나의 단위로 묶어서 처리한다.\n\n예를 들어, order service에서 order 관련 데이터를 저장하고, stock service에서 특정 재고를 감소시킨 뒤, payment service에서 PG사와 통신 후 결제가 정상적으로 이루어지면 결제 정보를 저장한다.\n\n만약, payment service에서 PG사 간 네트워크 통신 에러로 인해, 결제가 이루어지지 않는다면 대부분 DB에 write 한 작업들을 하나의 단위로 묶어 rollback 처리를 하도록 data manager에서 처리할 수 있다.\n\n<br>\n\n**MSA 환경에서 DB 리소스가 여러 개인 경우**\n![img](https://eeeasycode.github.io/src/images/msa.png)\n문제는 위와 같이 각각의 server도 분리되고, DB도 각 server마다 사용되는 MSA 환경의 폴리그랏 형태라면 transaction 들에 대한 관리는 어떻게 해야할까?\n\n## 문제 상황\nMSA 프로젝트를 진행하던 중, 회원가입 과정에서 나는 소셜 로그인 정보를 저장하는 Auth Service와 guest 상태의 유저를 저장하는 User Service 로직을 하나의 단위로 묶어 구현했다.\n\n<회원가입 flow>\n1. 소셜 로그인 진행\n2. User Server의 service에서 guest 상태 유저를 생성 \n3. 생성된 user의 id를 FK로 Auth Server의 service에서 소셜 로그인 정보를 저장\n\n근데 만약, guest 상태의 유저가 생성되었지만, auth 서버와의 통신 에러로 인해 예외 처리가 된다면 생성된 user는 어떻게 해야할까?\n\n## 해결 방안\n\n## 적용\n\n## 결과 \n"},{"excerpt":"NestJS에서의 DI와 인터페이스 SpringBoot 우선 SpringBoot에서 OCP와 DIP를 지키기 위해, DI하는 경우 인터페이스를 사용하는 것을 볼 수 있다. 간단하게, DI 받는 부분에서 private final UserService: userService 로 명시하는 것을 볼 수 있다. NestJS 그럼 NestJS도 SpringBoot와…","fields":{"slug":"/nestjs-interface-di/"},"frontmatter":{"date":"August 24, 2024","title":"NestJS에서 인터페이스 DI","tags":["NestJS"]},"rawMarkdownBody":"\n# NestJS에서의 DI와 인터페이스\n\n## SpringBoot\n\n우선 SpringBoot에서 OCP와 DIP를 지키기 위해, DI하는 경우 인터페이스를 사용하는 것을 볼 수 있다.\n\n```java\ninterface UserService {\n\tvoid signUp(..);\n}\n\n@Service\npublic class UserServiceImpl implements UserService {\n    @Override\n    public void signUp(..) {\n    \t...\n\t}\n}\n@RestController\npublic class UserController {\n\tprivate final UserService userService;\n        ...\n{\n```\n\n간단하게, DI 받는 부분에서 <code>private final UserService: userService</code> 로 명시하는 것을 볼 수 있다.\n\n\n## NestJS\n\n그럼 NestJS도 SpringBoot와 같은 개념이니까, 그대로 따라하면 정상적으로 동작할까?\n```ts\nexport interface UserService {\n    signUp(..);\n}\n\n@Injectable()\nexport class UserServiceImpl implements UserService {\n    signUp(..) {\n        ...\n    }\n}\n\n@Controller()\nexport class UserController {\n    constructor(\n        private readonly userService: UserService; \n    )\n    ...\n}\n```\n\n결과는  Nest can't resolve dependencies ~ 에러를 뱉어낸다. 의존성을 해결하지 못해 발생하는 에러인데, 왜 발생하는걸까? \n\n<br>\n\n### TS의 interface\nTypescript에서 제공하는 interface는 런타임 시 사라지게 된다. DI는 런타임 시점에서 동작하게 되는데, 해당 interface를 찾지 못해 의존성을 해결하지 못하는 것이다.\n\n그럼 그냥 사용하지 못하는걸까?\n\n<br>\n\n### Provider 설정\n\n그건 아니다. 다행히도 NestJS의 provider 설정을 직접 해주면 된다.\n\n```ts\n@Module({\n  controllers: [UserController],\n  providers: [\n    {\n      provide: 'USER_SERVICE',\n      useClass: UserServiceImpl,\n    },\n  ],\n})\nexport class UserModule {}\n\n@Controller()\nexport class UserController {\n    constructor(\n        @Inject('USER_SERVICE')\n        private readonly userService: UserService; \n    )\n    ...\n}\n```\n\n먼저, module의 providers에 Inject Token과 실제 구현 클래스를 명시해준다.\n그 뒤, DI 하는 부분에서 내가 명시한 Inject Token으로 Inject 받으면 문제 없이 인터페이스를 DI할 수 있게 된다.\n\n<br>\n\n# Reference\n[NestJS Providers](https://github.com/EeeasyCode/EeeasyCode.github.io/blob/main/contents/posts/nestjs-providers/index.md)\n"},{"excerpt":"TOSS AOP 라이브러리","fields":{"slug":"/toss-aop-review/"},"frontmatter":{"date":"July 20, 2024","title":"TOSS AOP 라이브러리","tags":["NestJS"]},"rawMarkdownBody":"\n\n# TOSS AOP 라이브러리\n"},{"excerpt":"Toss AOP 라이브러리 한글 문서 번역 왜 한글 문서 번역? 최근에 오픈소스 기여에 대해 관심이 생기고 바로 내가 기여할 수 있는 게 무엇일까를 고민하던 중, 어떤 블로그에서 영어 문서를 한글 문서로 번역하는 것부터 시작해보라는 말을 보게 되었다.  그래서, 내가 최근 가장 관심있게 보던 오픈소스인 TOSS의 AOP 라이브러리를 확인해보았고, 마침 영…","fields":{"slug":"/opensource-toss-aop/"},"frontmatter":{"date":"June 20, 2024","title":"Toss AOP 라이브러리 한글 문서 번역 기여","tags":["오픈소스","NestJS"]},"rawMarkdownBody":"\n# [Toss AOP 라이브러리] 한글 문서 번역\n\n## 왜 한글 문서 번역?\n최근에 오픈소스 기여에 대해 관심이 생기고 바로 내가 기여할 수 있는 게 무엇일까를 고민하던 중, 어떤 블로그에서 영어 문서를 한글 문서로 번역하는 것부터 시작해보라는 말을 보게 되었다. \n\n그래서, 내가 최근 가장 관심있게 보던 오픈소스인 TOSS의 AOP 라이브러리를 확인해보았고, 마침 영어 문서 밖에 없어 한글 문서 번역을 기여했다.\n\n어려운 내용은 크게 없었고, 내가 기여한 번역을 통해 누군가는 도움이 되었으면 하는 마음으로 진행했다.\n\n## 기여한 내용\nToss의 NodeJS Developer 챕터에서 만든 라이브러리의 사용 예제에 대해 문서 번역을 기여했다. \n\n## 느낀 점\n오픈소스 기여라고 하면 굉장히 어려운 것처럼 다가오는 것 같다. 사실은 한글 문서 번역도 나름이지만 어쨌든 누군가에게 편리함을 줄 수 있는 것에 대해 도움이 될 수 있다면 그것도 나는 기여했다고 생각한다.\n\n\n다음으로 TOSS/AOP 라이브러리가 무엇인지 자세히 분석해보려고 한다.\n\n[TOSS/AOP 라이브러리 분석](https://eeeasycode.github.io/toss-aop-review/)\n\n## Reference\n[기여한 PR Link](https://github.com/toss/nestjs-aop/pull/35 \"toss-github link\")\n\n"},{"excerpt":"Feature 빌드 속도를 개선하기 위해, yarn classic -> yarn berry (zero install) -> pnpm으로 마이그레이션 하는 과정과 docker multi-stage 적용, nestjs에서 swc를 통한 컴파일 속도 최적화를 진행했습니다. Situation 현재 저희는 AWS ECS를 통해 서버를 배포하고 있습니다. githu…","fields":{"slug":"/nestjs-build-time/"},"frontmatter":{"date":"June 18, 2024","title":"NestJS 빌드 속도 개선","tags":["NestJS","package manager","성능개선"]},"rawMarkdownBody":"\n# Feature\n\n빌드 속도를 개선하기 위해, **yarn classic -> yarn berry (zero install) -> pnpm**으로 마이그레이션 하는 과정과 **docker multi-stage** 적용, nestjs에서 **swc**를 통한 컴파일 속도 최적화를 진행했습니다.\n\n## Situation\n\n현재 저희는 **AWS ECS**를 통해 서버를 배포하고 있습니다. github의 코드가 **docker image**로 빌드되고, **AWS ECR**을 거쳐 **AWS ECS**의 인스턴스로 생성되는 파이프라인이 구성되어 있습니다.\n\n## Task\n\n- package 설치 속도 및 의존성 관리 개선\n- docker 빌드 속도 개선\n- nestjs 빌드 · 컴파일 속도 개선\n\n## Action\n\n### package manager 마이그레이션\n\n기존 yarn classic에서 yarn berry (zero-install)을 업그레이드한 뒤, 다양한 고려사항으로 인해 pnpm으로 최종 마이그레이션을 진행했습니다.\n\n실제 pacakge 설치 속도 및 크기를 크게 개선할 수 있었습니다.\n| yarn classic | pnpm |\n| ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |\n| 153.4s | 49.0s |\n\n> package manager 마이그레이션 과정은 해당 포스팅에서 확인할 수 있습니다.\n\n### docker multi-stage 적용\n\n### nestjs에서 swc 적용\n\n## Result\n\n해당 작업 결과로 docker 이미지 빌드 시간은 301.6s -> 112.6s 로 개선했고,\n이미지 용량도 1GB -> 830MB로 감소시킬 수 있었다.\n| yarn classic | pnpm |\n| ------------------------------------ | ------------------------------------ |\n| [+] Building 301.6s (12/12) FINISHED | [+] Building 112.6s (17/17) FINISHED |\n\n<img width=\"1157\" alt=\"upload_test\" src=\"https://imgur.com/zJUQ9n9.png\">\n"},{"excerpt":"Feature typeORM에서 연관관계가 없는 테이블 간 join 하는 방법 Tables User 테이블 Payment 테이블 각 테이블은 연관관계를 설정하지 않았고, payment 테이블에서 userId를 저장할 수 있게 했습니다. Join case 모든 user에 대한 payment 정보를 조회하기 위해 join을 합니다. 동작한 query 리턴된 …","fields":{"slug":"/typeorm-join/"},"frontmatter":{"date":"May 12, 2024","title":"연관관계 없이 join","tags":["nestjs","typeorm","database"]},"rawMarkdownBody":"\n# Feature\n\ntypeORM에서 연관관계가 없는 테이블 간 join 하는 방법\n\n## Tables\n\n### User 테이블\n\n<img width=\"1166\" alt=\"user_table\" src=\"https://eeeasycode.github.io/src/images/user_table.png\">\n\n### Payment 테이블\n\n<img width=\"1179\" alt=\"payment_table\" src=\"https://eeeasycode.github.io/src/images/payment_table.png\">\n\n각 테이블은 연관관계를 설정하지 않았고, payment 테이블에서 userId를 저장할 수 있게 했습니다.\n\n## Join case\n\n모든 user에 대한 payment 정보를 조회하기 위해 join을 합니다.\n\n```typescript\nasync leftJoin() {\n    return await this.usersRepository\n      .createQueryBuilder('user')\n      .leftJoinAndMapMany('user.payment', Payments, 'payment', 'user.id = payment.userId')\n      .getMany();\n}\n```\n\n### 동작한 query\n\n```shell\nquery: SELECT `user`.`id` AS `user_id`, `user`.`userEmail` AS `user_userEmail`, `user`.`password` AS `user_password`, `user`.`created_at` AS `user_created_at`, `user`.`updated_at` AS `user_updated_at`, `user`.`deleted_at` AS `user_deleted_at`, `payment`.`id` AS `payment_id`, `payment`.`userId` AS `payment_userId`, `payment`.`created_at` AS `payment_created_at`, `payment`.`updated_at` AS `payment_updated_at`, `payment`.`deleted_at` AS `payment_deleted_at` FROM `users` `user` LEFT JOIN `payments` `payment` ON  `user`.`id` = `payment`.`userId` AND `payment`.`deleted_at` IS NULL WHERE `user`.`deleted_at` IS NULL\n```\n\n### 리턴된 결과값\n\n```json\n[\n  {\n    \"id\": 1,\n    \"userEmail\": \"user1@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": [\n      {\n        \"id\": 4,\n        \"userId\": 1,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      },\n      {\n        \"id\": 1,\n        \"userId\": 1,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      }\n    ]\n  },\n  {\n    \"id\": 2,\n    \"userEmail\": \"user2@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": [\n      {\n        \"id\": 3,\n        \"userId\": 2,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      },\n      {\n        \"id\": 2,\n        \"userId\": 2,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      }\n    ]\n  },\n  {\n    \"id\": 3,\n    \"userEmail\": \"user3@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": [\n      {\n        \"id\": 5,\n        \"userId\": 3,\n        \"created_at\": \"2024-05-06T16:10:18.000Z\",\n        \"updated_at\": \"2024-05-06T16:10:18.000Z\",\n        \"deleted_at\": null\n      }\n    ]\n  },\n  {\n    \"id\": 4,\n    \"userEmail\": \"user4@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": []\n  },\n  {\n    \"id\": 5,\n    \"userEmail\": \"user5@example.com\",\n    \"password\": \"password123\",\n    \"created_at\": \"2024-05-06T16:08:37.000Z\",\n    \"updated_at\": \"2024-05-06T16:08:37.000Z\",\n    \"deleted_at\": null,\n    \"payment\": []\n  }\n]\n```\n"},{"excerpt":"Feature Image Upload 서버에서 Sharp 라이브러리를 사용해 Content-type 변경하는 기능 구현 Situation 기존 운영중인 서비스은 S3에 이미지 업로드 할 때, image/jpg로 업로드됩니다.\nJPG는 PNG에 비해 작은 용량의 크기로 사진을 압축할 수 있지만 WebP와 비교했을 때 화질면에서 크게 떨어집니다.\n또한, We…","fields":{"slug":"/nestjs-image-upload/"},"frontmatter":{"date":"April 03, 2024","title":"이미지 업로드 성능 개선","tags":["NestJS","성능개선"]},"rawMarkdownBody":"\n# Feature\n\nImage Upload 서버에서 Sharp 라이브러리를 사용해 Content-type 변경하는 기능 구현\n\n## Situation\n\n기존 운영중인 서비스은 S3에 이미지 업로드 할 때, image/jpg로 업로드됩니다.\nJPG는 PNG에 비해 작은 용량의 크기로 사진을 압축할 수 있지만 WebP와 비교했을 때 화질면에서 크게 떨어집니다.\n또한, Webp는 PNG에 비해 크기가 26%, JPEG 이미지보다 25~34% 더 작습니다.\n\n> 출처 : https://developers.google.com/speed/webp?hl=ko\n\n## Task\n\n- 업로드 할 이미지의 용량 축소 기능 구현\n- Sharp 라이브러리를 활용하여 이미지의 Content-Type을 image/webp 로 변환\n\n## Action\n\n- 이미지 업로드 API의 서비스 로직에 Sharp 라이브러리로 Image의 Buffer를 webp로 변환\n- 이미지 파일의 확장자를 .webp로 변환\n- S3 업로드 시, ContentType을 image/webp로 설정\n\n## Result\n\n테스트 결과 -> 파일 A, 파일 B\n\n> png 파일 업로드 -> 131.2 KB, 333.5 KB <br>\n> jpeg 파일 업로드 -> 86.0 KB, 241.8 KB <br> > **webp 파일 업로드 -> 50.9 KB, 128.2 KB** <br>\n\n로 webp 변환 시 저장 공간에 대한 효율성을 향상시킬 수 있습니다.\n이는 업로드에 대한 성능 뿐만 아니라, 실제 클라이언트에게 이미지 파일이 전달될 때에 확실한 성능 차이가 보여질 것으로 판단됩니다.\n\n<img width=\"1157\" alt=\"upload_test\" src=\"https://eeeasycode.github.io/src/images/test.png\">\n\n"},{"excerpt":"Tech Environment Python v3.12 actions/checkout@v3 actions/setup-python@v3 python code의 의존성을 위해 requirements.txt로 라이브러리 설치 member_list.json 해당 파일에 멤버 리스트를 등록하여 사용합니다. 이와 같은 형식으로 등록합니다. PR notificaiton…","fields":{"slug":"/github-slack-bot/"},"frontmatter":{"date":"February 27, 2024","title":"PR 리뷰어 할당 봇 만들기","tags":["github-action","자동화"]},"rawMarkdownBody":"\n## Tech Environment\n\n- Python v3.12\n- actions/checkout@v3\n- actions/setup-python@v3\n- python code의 의존성을 위해 requirements.txt로 라이브러리 설치\n\n## member_list.json\n\n해당 파일에 멤버 리스트를 등록하여 사용합니다.\n\n```json\n[\n  {\n    \"githubName\": \"CEethan\",\n    \"slackUserId\": \"U069RPHRU95\"\n  },\n  {\n    \"githubName\": \"EeeasyCode\",\n    \"slackUserId\": \"U069RPHRU95\"\n  }\n]\n```\n\n이와 같은 형식으로 등록합니다.\n\n---\n\n## PR notificaiton bot\n\n> 지정한 레포지토리의 PR이 남아있는지 확인 후, 평일 지정한 시간에 Slack을 통해 알림을 전송하는 Bot 입니다.\n\n### Code Description\n\n### pr-notification.py\n\n- python 코드로 slack, github 연동\n- github repository 정보를 가져와 slack 메시지 형태로 가공\n- 가공된 메시지를 지정한 slack 채널로 전송\n\n### pr-notification-bot.yml\n\n- schedule -> cron 표현식을 통해 지정한 시간마다 동작하도록\n  스케줄링\n- 이후, github secret을 사용해 env 값 설정\n- github action을 활용하여 pr-notification.py를 실행\n\n---\n\n## assign reviewer bot\n\n> PR을 올리면 랜덤으로 리뷰어가 할당되어 Slack을 통해 알림받을 수 있습니다.\n\n### Code Description\n\n### assign-reviewer.py\n\n- python 코드로 slack, github 연동\n- python 내부 로직에 의해, 자동으로 리뷰어를 할당하여 등록함\n- 리뷰어로 할당된 멤버에게 Slack 메시지 전송\n\n### assign-reviewer-bot.yml\n\n- PR 이벤트를 감지하여 PR이 올라올 경우 해당 action 트리거\n- 이후, github secret을 사용해 env 값 설정\n- github action을 활용하여 assign-reviewer.py를 실행\n\n---\n\n## review check bot\n\n> 리뷰어가 PR에 대한 리뷰를 완료하면 PR 담당자에게 Slack 메시지를 전송합니다.\n\n### Code Description\n\n### review-check.py\n\n- python 코드로 slack, github 연동\n- python 내부 로직에 의해 PR 담당자에게 리뷰가 되었음을 알림\n\n### review-check-bot.yml\n\n- PR의 리뷰 이벤트를 감지하여 리뷰가 등록된 경우 해당 action\n  트리거\n- 이후, github secret을 사용해 env 값 설정\n- github action을 활용하여 review-check.py를 실행\n"},{"excerpt":"동시에 같은 DB 테이블 row를 업데이트 하는 상황은 \"DB의 동시성 이슈\"으로 생각해보면 좋을 것 같다. DB의 동시성 이슈 동시성이란 여러 요청이 동시에 동일한 자원(Data)에 접근하고 수정하려는 것을 말한다. 이로 인해, 발생하게 되는 문제를 동시성 문제라고 한다. 동시성 문제로 Data의 무결성이 깨지고 의도하지 않은 결과를 반환하게 되는 문제…","fields":{"slug":"/concurrency-issue/"},"frontmatter":{"date":"February 16, 2024","title":"동시성 이슈 해결해보기","tags":["database","문제해결"]},"rawMarkdownBody":"\n동시에 같은 DB 테이블 row를 업데이트 하는 상황은 <Strong>\"DB의 동시성 이슈\"</Strong>으로 생각해보면 좋을 것 같다.\n\n# DB의 동시성 이슈\n\n<Strong>동시성</Strong>이란 여러 요청이 동시에 동일한 자원(Data)에 접근하고 수정하려는 것을 말한다. 이로 인해, 발생하게 되는 문제를 동시성 문제라고 한다. 동시성 문제로 Data의 무결성이 깨지고 의도하지 않은 결과를 반환하게 되는 문제들이 발생한다.\n\n<hr>\n\n# 해결방안\n\n해결방안에는 DB수준에서의 락, 프레임워크 or 언어 수준에서의 동기화 등이 존재한다. 여기서는 DB수준에서의 락에 대해 알아보려고 한다.\n\n> 1. 테이블의 row에 접근 시, Lock을 걸고 다른 Lock이 걸려있지 않는 경우에만 수정을 가능하게 함\n> 2. 수정할 때 내가 먼저 수정했음을 명시하여 다른 곳에서 동일한 조건으로 값을 수정할 수 없게 함\n\n위처럼, 자원 경쟁에 대한 관점으로 두 가지의 방법을 생각해볼 수 있다. 이는 비관적 락과 낙관적 락을 나누는 기준이 된다.\n\n<hr>\n\n## 비관적 락(Pessimistic Lock)\n\n현재 수정하려는 data가 언제든지 다른 요청에 의해 수정될 가능성을 고려하여 해당 data에 Lock을 거는 방식\n트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작한다.\n\n- <code><Strong>공유락 (Shared Lock)</Strong></code> : Read Lock이라고 하는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만 하기 때문에 같은 공유락끼리는 동시에 접근이 가능하지만, 쓰기 작업은 막는다.\n\n- <code><Strong>베타락 (Exclusive Lock)</Strong></code> : Write Lock이라고 하는 배터락은, 데이터를 변경할 때 사용하는 락이다. 트랜잭션이 완료될 때까지 유지되며, 락이 끝나기 전까지 읽기/쓰기를 모두 막는다.\n\n### 장점\n\n- data의 무결성을 보존할 수 있다.\n- 충돌 발생 미리 방지\n\n### 단점\n\n- Lock으로 인해 이후의 다른 요청은 대기 상태로 빠짐\n- 기존 Lock의 트랜잭션이 commit/rollback으로 끝내면 이후 대기 요청을 실행\n\n<hr>\n\n## 낙관적 락(Optimistic Lock)\n\n자원에 락을 걸지 않고, 동시성 문제가 발생하면 그때 처리한다.\n숫자/시간 컬럼을 만들어 수정 시 그 data를 증가/갱신함 -> data 수정 시 컬럼을 비교하여 일치하는지 확인\n\n- Version과 같은 <Strong>별도의 컬럼을 추가</Strong>하여 충돌 발생을 막는다.\n  Version -> hashcode / timestamp 등을 사용하여 상태를 보고 충돌 확인함\n\n- 충돌 발생 시, DB가 아닌 애플리케이션 단에서 처리를 한다.\n  낙관적 락은 UPDATE에 실패해도 자동으로 예외를 던지지 않고, 단순히 0개의 row를 업데이트한다.\n  따라서 이때 여러 작업이 묶은 트랜잭션 요청 실패 시,<Strong>우리가 직접 롤백 처리</Strong>를 해줘야 한다.\n\n### 장점\n\n- 구현하기 용이함\n- 지속적인 락으로 인한 성능저하를 막을 수 있음\n\n### 단점\n\n- Version Conflict 시, 처리해야 할 외부 요인이 존재함\n\n<hr>\n\n## 성능 비교\n\n> <Strong>비관적 락 < 낙관적 락 </Strong>\n\n- 낙관적 락은 트랜잭션이 필요하지 않기 때문에 성능적으로 우수함\n- 비관적 락은 데이터 자체에 락을 걸기 때문에 동시성이 떨어져 성능 저하가 발생하며, 서로의 자원이 필요할 경우에는 교착상태가 발생할 가능성 존재\n\n> <Strong>충돌이 많이 발생하는 환경</Strong>\n\n충돌 발생 시, 비관적 락은 트랜잭션을 롤백하면 끝남. 하지만 낙관적 락은 까다로운 수동 롤백 처리와 성능 측면에서도 Update를 한번씩 더 해줘야 하기 떄문에, 성능 저하가 발생할 수 있음\n\n<Strong> 데이터의 무결성 + 데이터의 충돌이 많이 발생할 것 같은 경우 -> 비관적 락\n데이터 충돌이 적을 것 같은 경우 + 조회 작업이 많아 동시 접근 성능이 중요 -> 낙관적 락 </Strong>\n"},{"excerpt":"이번에 진행한 프로젝트에서 나는 CloudType을 사용하여 NestJS 기반 서버를 무료로 배포하였다. 무료로 서버를 배포할 수 있다는 것이 정말 큰 장점이었지만, CloudType의 무료 티어의 경우 연속 실행 제한이 걸려 매일 오전 3~9시 사이 프리티어로 구동 중인 서비스는 자동으로 중지 상태로 변경되는 문제가 존재한다.  사실, 정지되는 것은 문…","fields":{"slug":"/github-healthcheck-bot/"},"frontmatter":{"date":"December 27, 2023","title":"github-action + slack으로 서버 헬스체크하기","tags":["github-action","자동화"]},"rawMarkdownBody":"\n이번에 진행한 프로젝트에서 나는 CloudType을 사용하여 NestJS 기반 서버를 무료로 배포하였다. 무료로 서버를 배포할 수 있다는 것이 정말 큰 장점이었지만, CloudType의 무료 티어의 경우 **연속 실행 제한**이 걸려 매일 오전 3~9시 사이 프리티어로 구동 중인 서비스는 자동으로 중지 상태로 변경되는 문제가 존재한다.\n\n![](https://velog.velcdn.com/images/eeeasy-code/post/227fe906-018a-41b5-92e3-25f37f0a37c8/image.png)\n\n사실, 정지되는 것은 문제가 되지 않았다. 웹 사이트에 접속하는 사용자의 수도 많지 않았고, 오전 3~9시 사이에 접속하는 사용자는 더욱 낮을 것이라고 판단했기 때문이다. 그럼에도 일단 언제 중지될지 모르는 서버와 꺼져있는 서버를 재가동시키는 것을 깜빡하는 경우에 소중한 사용자의 데이터가 저장되지 못하는 일이 발생했다. 프로젝트 배포에서 가장 중요했던 사용자의 구매량과 버튼 클릭 수를 DB 서버에 저장하고 있었기에 이는 우리에게 나름 크리티컬한 문제가 되었다.\n\n## 대응 방안\n\n일단 초기 대응 방안은 그저 9시 이후에 CloudType 프로젝트 관리창에서 꺼져있는 나의 서버를 다시 켰다. 그런데 가끔 9시 이후에도 잘 켜져있다가 이후에 꺼지는 경우도 있었던 것으로 기억한다. 그래서, 언제꺼질지 몰라 지속적으로 확인했었다. 이는 너무 귀찮기도 했고 짜증나기도 했다. 그렇게 점점 서버 재가동을 놓치는 시간이 많아졌고, 서버는 잠들어 있는 시간이 더 길어졌다.\n\n문제를 해결하기 위해, 아이디어를 구상해 보았다.\n\n> 1. 서버 중단 시, 내부 로직에 중단되기 직전 메일 등의 알림 기능을 구현\n> 2. 프론트엔드 단에서 서버의 응답이 정상적으로 오지않을 경우를 확인\n> 3. 헬스체크 서버를 구현 후 배포하여 주기적으로 확인\n\n내 머리 속에 든 생각은 총 3가지였다. 우선 첫 번째 아이디어를 진행보았다. 서버 내부 메인 로직에 아래와 같은 코드를 넣어 서버가 다운될 시점에 로그 파일을 남길 수 있도록 진행했다.\n\n```\nprocess.on('exit', code => {\n  console.log(code)\n  logger.log({\n    level: 'error',\n    message: 'exit'\n  })\n})\n\nprocess.on('SIGINT', code => {\n  console.log(code)\n  logger.log({\n    level: 'error',\n    message: 'sigint'\n  })\n})\n```\n\n하지만, 서버가 중단되고 재가동 후 확인해본 결과 로그 파일은 생성되지 않았다. 그 원인에 대해 아직도 명확한 해답을 찾지는 못했지만 스스로 생각해본 결과 배포 시스템이 중단되는 것과 내부 로직은 관련이 없고, AWS처럼 시스템 중단 시 발생하는 이벤트가 존재할텐데 이를 활용해야 할 것 같다는 생각이 들었다. CloudType 공식문서에는 따로 나와있는 내용이 없었다.\n\n두 번째 아이디어는 프론트엔드 단에서 내가 배포한 서버의 API를 호출했을 때, 응답이 정상적으로 오지않고 500 등의 에러를 응답할 경우에 알림을 보내는 기능을 생각해봤다. 사실 이 아이디어도 나름 깔끔하고 좋다고 생각했지만, 프론트엔드 개발자 분께서 본인의 코드를 건드는 것을 별로 좋아하지 않았고 그래서 일단 내가 스스로 해결해보려 노력해봤다.\n\n마지막 아이디어를 지금 채택해 사용 중인데, 초기에 생각했던 것은 헬스체크 서버에 기존 서버의 헬스체크 Api를 스케줄링하는 기능을 구현해 배포하려고 했다. 생각해보니 그럼 서버가 두 개나 띄워져있는 것인데 이는 낭비라고 생각이 들었다. 그래서 찾은 방법이 ** Github Action으로 헬스 체크**하는 것이었다. Github Action으로 스케줄링을 걸어놓고 특정 시간에 한 번씩 서버의 상태를 확인하고, 이를 Slack으로 알림을 전송하는 것을 생각했다.\n\n## Github Action으로 헬스체크\n\ngithub action에 등록한 헬스체크 기능을 코드로 먼저 보겠다.\n\n```\nname: health check\n\non:\n  # 스케줄링을 설정함 / 매분마다 한 번씩 이벤트를 트리거함\n  schedule:\n    - cron: '*/1 * * * *'\n  # workflow_dispath는 수동으로 이벤트를 트리거할 수 있도록 해주는 것을 의미함\n  workflow_dispatch:\n\njobs:\n  healthcheck:\n    runs-on: ubuntu-latest\n    steps:\n      # 지정한 서버에 대해 헬스 체크 진행\n      - name: Release API Health Check\n        uses: jtalk/url-health-check-action@v3\n        with:\n          github_token: ${{ secrets.GHP_TOKEN }}\n          url: ${{ secrets.RELEASE_URI }}\n          max-attempts: 3 # 시도 횟수\n          retry-delay: 1s # 시도 간격\n\n\t  # 트리거된 이벤트의 내용을 slack으로 전달\n      - name: action-slack\n        uses: 8398a7/action-slack@v3\n        with:\n          status: ${{ job.status }}\n          github_token: ${{ secrets.GHP_TOKEN }}\n          author_name: Github Action Health Check\n          fields: repo,message,commit,action,eventName,ref,workflow,job,took # 보낼 정보들\n        env:\n          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEB_HOOK_URL }}\n        if: always() # 특정 조건에 상관없이 항상 실행\n\n```\n\n작성된 github action의 healthCheck 플로우는 다음과 같다. 이 후, slack의 incoming-webhook을 등록하여 진행하면 문제없이 서버의 healthCheck 기능이 정상적으로 작동된다. 덕분에 서버가 중단된 경우 Slack을 통해 알림을 받을 수 있게 되었고, 귀찮게 내가 한번씩 접속해서 서버가 중단되었는지 확인하지 않아도 알 수 있게 되어 너무 편하다.\n\n| 서버 정상 작동                                                                                       | 서버 중단 시                                                                                         |\n| ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |\n| ![](https://velog.velcdn.com/images/eeeasy-code/post/2ff2fd43-d7ec-4cb7-98b4-1618a3ac1b7b/image.png) | ![](https://velog.velcdn.com/images/eeeasy-code/post/0db7fdfe-7582-4679-bd0c-eb87353f6925/image.png) |\n\n![](https://velog.velcdn.com/images/eeeasy-code/post/81ed5cf4-526b-4085-98c3-9d4c04d9a76e/image.png)\n\n## 발생한 문제들\n\n1. Github Action에서 발생하는 <code>\"Resource not accessible by integration\"</code> 문제 발생 -> github token을 넣어주면 해결 가능\n2. <code>\"The process '/usr/bin/git' failed with exit code 1\"</code> 문제 발생 -> healthCheck할 서버의 url이 정상적인 응답을 보내는지 확인 후 설정\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}